
../benchmarks/adpcm/adpcm:     file format ss-coff-little

Disassembly of section .text:
00400140 <__start> lw $16,0($29)
00400148 <__start+0x8> lui $28,4097
00400150 <__start+0x10> addiu $28,$28,-30864
00400158 <__start+0x18> addiu $17,$29,4
00400160 <__start+0x20> addiu $3,$17,4
00400168 <__start+0x28> sll $2,$16,0x2
00400170 <__start+0x30> addu $3,$3,$2
00400178 <__start+0x38> addu $18,$0,$3
00400180 <__start+0x40> sw $18,-32636($28)
00400188 <__start+0x48> addiu $29,$29,-24
00400190 <__start+0x50> addu $4,$0,$16
00400198 <__start+0x58> addu $5,$0,$17
004001a0 <__start+0x60> addu $6,$0,$18
004001a8 <__start+0x68> jal 00403280 <__libc_init>
004001b0 <__start+0x70> sw $0,-32640($28)
004001b8 <__start+0x78> addu $4,$0,$16
004001c0 <__start+0x80> addu $5,$0,$17
004001c8 <__start+0x88> addu $6,$0,$18
004001d0 <__start+0x90> jal 00402eb8 <main>
004001d8 <__start+0x98> addu $4,$0,$2
004001e0 <__start+0xa0> jal 004032b0 <exit>
004001e8 <__start+0xa8> nop 
my_abs():
../benchmarks/adpcm/adpcm.c:266
/* returns il and ih stored together */

/* MAX: 1 */
int my_abs(int n)
{
004001f0 <my_abs> addiu $29,$29,-16
004001f8 <my_abs+0x8> sw $30,8($29)
00400200 <my_abs+0x10> addu $30,$0,$29
00400208 <my_abs+0x18> sw $4,16($30)
../benchmarks/adpcm/adpcm.c:269
  int m;

  if (n >= 0) m = n;
00400210 <my_abs+0x20> lw $2,16($30)
00400218 <my_abs+0x28> bltz $2,00400238 <my_abs+0x48>
00400220 <my_abs+0x30> lw $2,16($30)
00400228 <my_abs+0x38> sw $2,0($30)
00400230 <my_abs+0x40> j 00400250 <my_abs+0x60>
../benchmarks/adpcm/adpcm.c:270
  else m = -n;
00400238 <my_abs+0x48> lw $2,16($30)
00400240 <my_abs+0x50> subu $3,$0,$2
00400248 <my_abs+0x58> sw $3,0($30)
../benchmarks/adpcm/adpcm.c:271
  return m;
00400250 <my_abs+0x60> lw $2,0($30)
00400258 <my_abs+0x68> j 00400260 <my_abs+0x70>
../benchmarks/adpcm/adpcm.c:272
}
00400260 <my_abs+0x70> addu $29,$0,$30
00400268 <my_abs+0x78> lw $30,8($29)
00400270 <my_abs+0x80> addiu $29,$29,16
00400278 <my_abs+0x88> jr $31
my_fabs():
../benchmarks/adpcm/adpcm.c:276

/* MAX: 1 */
int my_fabs(int n)
{
00400280 <my_fabs> addiu $29,$29,-16
00400288 <my_fabs+0x8> sw $30,8($29)
00400290 <my_fabs+0x10> addu $30,$0,$29
00400298 <my_fabs+0x18> sw $4,16($30)
../benchmarks/adpcm/adpcm.c:279
  int f;

  if (n >= 0) f = n;
004002a0 <my_fabs+0x20> lw $2,16($30)
004002a8 <my_fabs+0x28> bltz $2,004002c8 <my_fabs+0x48>
004002b0 <my_fabs+0x30> lw $2,16($30)
004002b8 <my_fabs+0x38> sw $2,0($30)
004002c0 <my_fabs+0x40> j 004002e0 <my_fabs+0x60>
../benchmarks/adpcm/adpcm.c:280
  else f = -n;
004002c8 <my_fabs+0x48> lw $2,16($30)
004002d0 <my_fabs+0x50> subu $3,$0,$2
004002d8 <my_fabs+0x58> sw $3,0($30)
../benchmarks/adpcm/adpcm.c:281
  return f;
004002e0 <my_fabs+0x60> lw $2,0($30)
004002e8 <my_fabs+0x68> j 004002f0 <my_fabs+0x70>
../benchmarks/adpcm/adpcm.c:282
}
004002f0 <my_fabs+0x70> addu $29,$0,$30
004002f8 <my_fabs+0x78> lw $30,8($29)
00400300 <my_fabs+0x80> addiu $29,$29,16
00400308 <my_fabs+0x88> jr $31
my_sin():
../benchmarks/adpcm/adpcm.c:285

int my_sin(int rad)
{
00400310 <my_sin> addiu $29,$29,-40
00400318 <my_sin+0x8> sw $31,36($29)
00400320 <my_sin+0x10> sw $30,32($29)
00400328 <my_sin+0x18> addu $30,$0,$29
00400330 <my_sin+0x20> sw $4,40($30)
../benchmarks/adpcm/adpcm.c:287
  int diff;
  int app=0;
00400338 <my_sin+0x28> sw $0,20($30)
../benchmarks/adpcm/adpcm.c:289

  int inc = 1;
00400340 <my_sin+0x30> addiu $2,$0,1
00400348 <my_sin+0x38> sw $2,24($30)
../benchmarks/adpcm/adpcm.c:292

  /* MAX dependent on rad's value, say 50 */
  while (rad > 2*PI)
00400350 <my_sin+0x40> lw $2,40($30)
00400358 <my_sin+0x48> slti $3,$2,6283
00400360 <my_sin+0x50> beq $3,$0,00400370 <my_sin+0x60>
00400368 <my_sin+0x58> j 00400390 <my_sin+0x80>
../benchmarks/adpcm/adpcm.c:293
      rad -= 2*PI;
00400370 <my_sin+0x60> lw $2,40($30)
00400378 <my_sin+0x68> addiu $3,$2,-6282
00400380 <my_sin+0x70> sw $3,40($30)
00400388 <my_sin+0x78> j 00400350 <my_sin+0x40>
../benchmarks/adpcm/adpcm.c:295
  /* MAX dependent on rad's value, say 50 */
  while (rad < -2*PI)
00400390 <my_sin+0x80> lw $2,40($30)
00400398 <my_sin+0x88> slti $3,$2,-6282
004003a0 <my_sin+0x90> bne $3,$0,004003b0 <my_sin+0xa0>
004003a8 <my_sin+0x98> j 004003d0 <my_sin+0xc0>
../benchmarks/adpcm/adpcm.c:296
      rad += 2*PI;
004003b0 <my_sin+0xa0> lw $2,40($30)
004003b8 <my_sin+0xa8> addiu $3,$2,6282
004003c0 <my_sin+0xb0> sw $3,40($30)
004003c8 <my_sin+0xb8> j 00400390 <my_sin+0x80>
../benchmarks/adpcm/adpcm.c:297
   diff = rad;
004003d0 <my_sin+0xc0> lw $2,40($30)
004003d8 <my_sin+0xc8> sw $2,16($30)
../benchmarks/adpcm/adpcm.c:298
   app = diff;
004003e0 <my_sin+0xd0> lw $2,16($30)
004003e8 <my_sin+0xd8> sw $2,20($30)
../benchmarks/adpcm/adpcm.c:299
  diff = (diff * (-(rad*rad))) /
004003f0 <my_sin+0xe0> lw $2,40($30)
004003f8 <my_sin+0xe8> lw $3,40($30)
00400400 <my_sin+0xf0> mult $2,$3
00400408 <my_sin+0xf8> mflo $2
00400410 <my_sin+0x100> subu $3,$0,$2
00400418 <my_sin+0x108> lw $4,16($30)
00400420 <my_sin+0x110> mult $3,$4
00400428 <my_sin+0x118> mflo $2
00400430 <my_sin+0x120> lw $3,24($30)
00400438 <my_sin+0x128> addu $4,$0,$3
00400440 <my_sin+0x130> sll $3,$4,0x1
00400448 <my_sin+0x138> addiu $4,$3,1
00400450 <my_sin+0x140> addu $3,$0,$4
00400458 <my_sin+0x148> sll $4,$3,0x1
00400460 <my_sin+0x150> lw $5,24($30)
00400468 <my_sin+0x158> mult $4,$5
00400470 <my_sin+0x160> mflo $3
00400478 <my_sin+0x168> div $0,$2,$3
00400480 <my_sin+0x170> bne $3,$0,00400490 <my_sin+0x180>
00400488 <my_sin+0x178> break 
00400490 <my_sin+0x180> addiu $1,$0,-1
00400498 <my_sin+0x188> bne $3,$1,004004b8 <my_sin+0x1a8>
004004a0 <my_sin+0x190> lui $1,32768
004004a8 <my_sin+0x198> bne $2,$1,004004b8 <my_sin+0x1a8>
004004b0 <my_sin+0x1a0> break 
004004b8 <my_sin+0x1a8> mflo $2
004004c0 <my_sin+0x1b0> sw $2,16($30)
../benchmarks/adpcm/adpcm.c:301
     ((2 * inc) * (2 * inc + 1));
  app = app + diff;
004004c8 <my_sin+0x1b8> lw $2,20($30)
004004d0 <my_sin+0x1c0> lw $3,16($30)
004004d8 <my_sin+0x1c8> addu $2,$2,$3
004004e0 <my_sin+0x1d0> sw $2,20($30)
../benchmarks/adpcm/adpcm.c:302
  inc++;
004004e8 <my_sin+0x1d8> lw $3,24($30)
004004f0 <my_sin+0x1e0> addiu $2,$3,1
004004f8 <my_sin+0x1e8> addu $3,$0,$2
00400500 <my_sin+0x1f0> sw $3,24($30)
../benchmarks/adpcm/adpcm.c:305
  /* REALLY: while(my_fabs(diff) >= 0.00001) { */
  /* MAX: 1000 */
  while(my_fabs(diff) >= 1) {
00400508 <my_sin+0x1f8> lw $4,16($30)
00400510 <my_sin+0x200> jal 00400280 <my_fabs>
00400518 <my_sin+0x208> bgtz $2,00400528 <my_sin+0x218>
00400520 <my_sin+0x210> j 00400648 <my_sin+0x338>
../benchmarks/adpcm/adpcm.c:306
    diff = (diff * (-(rad*rad))) /
00400528 <my_sin+0x218> lw $2,40($30)
00400530 <my_sin+0x220> lw $3,40($30)
00400538 <my_sin+0x228> mult $2,$3
00400540 <my_sin+0x230> mflo $2
00400548 <my_sin+0x238> subu $3,$0,$2
00400550 <my_sin+0x240> lw $4,16($30)
00400558 <my_sin+0x248> mult $3,$4
00400560 <my_sin+0x250> mflo $2
00400568 <my_sin+0x258> lw $3,24($30)
00400570 <my_sin+0x260> addu $4,$0,$3
00400578 <my_sin+0x268> sll $3,$4,0x1
00400580 <my_sin+0x270> addiu $4,$3,1
00400588 <my_sin+0x278> addu $3,$0,$4
00400590 <my_sin+0x280> sll $4,$3,0x1
00400598 <my_sin+0x288> lw $5,24($30)
004005a0 <my_sin+0x290> mult $4,$5
004005a8 <my_sin+0x298> mflo $3
004005b0 <my_sin+0x2a0> div $0,$2,$3
004005b8 <my_sin+0x2a8> bne $3,$0,004005c8 <my_sin+0x2b8>
004005c0 <my_sin+0x2b0> break 
004005c8 <my_sin+0x2b8> addiu $1,$0,-1
004005d0 <my_sin+0x2c0> bne $3,$1,004005f0 <my_sin+0x2e0>
004005d8 <my_sin+0x2c8> lui $1,32768
004005e0 <my_sin+0x2d0> bne $2,$1,004005f0 <my_sin+0x2e0>
004005e8 <my_sin+0x2d8> break 
004005f0 <my_sin+0x2e0> mflo $2
004005f8 <my_sin+0x2e8> sw $2,16($30)
../benchmarks/adpcm/adpcm.c:308
	((2 * inc) * (2 * inc + 1));
    app = app + diff;
00400600 <my_sin+0x2f0> lw $2,20($30)
00400608 <my_sin+0x2f8> lw $3,16($30)
00400610 <my_sin+0x300> addu $2,$2,$3
00400618 <my_sin+0x308> sw $2,20($30)
../benchmarks/adpcm/adpcm.c:309
    inc++;
00400620 <my_sin+0x310> lw $3,24($30)
00400628 <my_sin+0x318> addiu $2,$3,1
00400630 <my_sin+0x320> addu $3,$0,$2
00400638 <my_sin+0x328> sw $3,24($30)
../benchmarks/adpcm/adpcm.c:310
  }
00400640 <my_sin+0x330> j 00400508 <my_sin+0x1f8>
../benchmarks/adpcm/adpcm.c:312

  return app;
00400648 <my_sin+0x338> lw $2,20($30)
00400650 <my_sin+0x340> j 00400658 <my_sin+0x348>
../benchmarks/adpcm/adpcm.c:313
}
00400658 <my_sin+0x348> addu $29,$0,$30
00400660 <my_sin+0x350> lw $31,36($29)
00400668 <my_sin+0x358> lw $30,32($29)
00400670 <my_sin+0x360> addiu $29,$29,40
00400678 <my_sin+0x368> jr $31
my_cos():
../benchmarks/adpcm/adpcm.c:317


int my_cos(int rad)
{
00400680 <my_cos> addiu $29,$29,-24
00400688 <my_cos+0x8> sw $31,20($29)
00400690 <my_cos+0x10> sw $30,16($29)
00400698 <my_cos+0x18> addu $30,$0,$29
004006a0 <my_cos+0x20> sw $4,24($30)
../benchmarks/adpcm/adpcm.c:318
  return (my_sin (PI / 2 - rad));
004006a8 <my_cos+0x28> addiu $2,$0,1570
004006b0 <my_cos+0x30> lw $3,24($30)
004006b8 <my_cos+0x38> subu $2,$2,$3
004006c0 <my_cos+0x40> addu $4,$0,$2
004006c8 <my_cos+0x48> jal 00400310 <my_sin>
004006d0 <my_cos+0x50> addu $3,$0,$2
004006d8 <my_cos+0x58> addu $2,$0,$3
004006e0 <my_cos+0x60> j 004006e8 <my_cos+0x68>
../benchmarks/adpcm/adpcm.c:319
}
004006e8 <my_cos+0x68> addu $29,$0,$30
004006f0 <my_cos+0x70> lw $31,20($29)
004006f8 <my_cos+0x78> lw $30,16($29)
00400700 <my_cos+0x80> addiu $29,$29,24
00400708 <my_cos+0x88> jr $31
encode():
../benchmarks/adpcm/adpcm.c:324


/* MAX: 1 */
int encode(int xin1,int xin2)
{
00400710 <encode> addiu $29,$29,-64
00400718 <encode+0x8> sw $31,60($29)
00400720 <encode+0x10> sw $30,56($29)
00400728 <encode+0x18> addu $30,$0,$29
00400730 <encode+0x20> sw $4,64($30)
00400738 <encode+0x28> sw $5,68($30)
../benchmarks/adpcm/adpcm.c:331
    int i;
    int *h_ptr,*tqmf_ptr,*tqmf_ptr1;
    long int xa,xb;
    int decis;

/* transmit quadrature mirror filters implemented here */
    h_ptr = h;
00400740 <encode+0x30> lui $2,4096
00400748 <encode+0x38> addiu $2,$2,96
00400750 <encode+0x40> sw $2,28($30)
../benchmarks/adpcm/adpcm.c:332
    tqmf_ptr = tqmf;
00400758 <encode+0x48> lui $2,4096
00400760 <encode+0x50> addiu $2,$2,2656
00400768 <encode+0x58> sw $2,32($30)
../benchmarks/adpcm/adpcm.c:333
    xa = (long)(*tqmf_ptr++) * (*h_ptr++);
00400770 <encode+0x60> lw $2,32($30)
00400778 <encode+0x68> addiu $3,$2,4
00400780 <encode+0x70> sw $3,32($30)
00400788 <encode+0x78> lw $3,28($30)
00400790 <encode+0x80> addiu $4,$3,4
00400798 <encode+0x88> sw $4,28($30)
004007a0 <encode+0x90> lw $2,0($2)
004007a8 <encode+0x98> lw $3,0($3)
004007b0 <encode+0xa0> mult $2,$3
004007b8 <encode+0xa8> mflo $2
004007c0 <encode+0xb0> sw $2,40($30)
../benchmarks/adpcm/adpcm.c:334
    xb = (long)(*tqmf_ptr++) * (*h_ptr++);
004007c8 <encode+0xb8> lw $2,32($30)
004007d0 <encode+0xc0> addiu $3,$2,4
004007d8 <encode+0xc8> sw $3,32($30)
004007e0 <encode+0xd0> lw $3,28($30)
004007e8 <encode+0xd8> addiu $4,$3,4
004007f0 <encode+0xe0> sw $4,28($30)
004007f8 <encode+0xe8> lw $2,0($2)
00400800 <encode+0xf0> lw $3,0($3)
00400808 <encode+0xf8> mult $2,$3
00400810 <encode+0x100> mflo $2
00400818 <encode+0x108> sw $2,44($30)
../benchmarks/adpcm/adpcm.c:337
/* main multiply accumulate loop for samples and coefficients */
    /* MAX: 10 */
    for(i = 0 ; i < 10 ; i++) {
00400820 <encode+0x110> sw $0,24($30)
00400828 <encode+0x118> lw $2,24($30)
00400830 <encode+0x120> slti $3,$2,10
00400838 <encode+0x128> bne $3,$0,00400848 <encode+0x138>
00400840 <encode+0x130> j 00400940 <encode+0x230>
../benchmarks/adpcm/adpcm.c:338
        xa += (long)(*tqmf_ptr++) * (*h_ptr++);
00400848 <encode+0x138> lw $2,32($30)
00400850 <encode+0x140> addiu $3,$2,4
00400858 <encode+0x148> sw $3,32($30)
00400860 <encode+0x150> lw $3,28($30)
00400868 <encode+0x158> addiu $4,$3,4
00400870 <encode+0x160> sw $4,28($30)
00400878 <encode+0x168> lw $2,0($2)
00400880 <encode+0x170> lw $3,0($3)
00400888 <encode+0x178> mult $2,$3
00400890 <encode+0x180> mflo $2
00400898 <encode+0x188> lw $3,40($30)
004008a0 <encode+0x190> addu $2,$3,$2
004008a8 <encode+0x198> sw $2,40($30)
../benchmarks/adpcm/adpcm.c:339
        xb += (long)(*tqmf_ptr++) * (*h_ptr++);
004008b0 <encode+0x1a0> lw $2,32($30)
004008b8 <encode+0x1a8> addiu $3,$2,4
004008c0 <encode+0x1b0> sw $3,32($30)
004008c8 <encode+0x1b8> lw $3,28($30)
004008d0 <encode+0x1c0> addiu $4,$3,4
004008d8 <encode+0x1c8> sw $4,28($30)
004008e0 <encode+0x1d0> lw $2,0($2)
004008e8 <encode+0x1d8> lw $3,0($3)
004008f0 <encode+0x1e0> mult $2,$3
004008f8 <encode+0x1e8> mflo $2
00400900 <encode+0x1f0> lw $3,44($30)
00400908 <encode+0x1f8> addu $2,$3,$2
00400910 <encode+0x200> sw $2,44($30)
../benchmarks/adpcm/adpcm.c:337
00400918 <encode+0x208> lw $3,24($30)
00400920 <encode+0x210> addiu $2,$3,1
00400928 <encode+0x218> addu $3,$0,$2
00400930 <encode+0x220> sw $3,24($30)
00400938 <encode+0x228> j 00400828 <encode+0x118>
../benchmarks/adpcm/adpcm.c:342
    }
/* final mult/accumulate */
    xa += (long)(*tqmf_ptr++) * (*h_ptr++);
00400940 <encode+0x230> lw $2,32($30)
00400948 <encode+0x238> addiu $3,$2,4
00400950 <encode+0x240> sw $3,32($30)
00400958 <encode+0x248> lw $3,28($30)
00400960 <encode+0x250> addiu $4,$3,4
00400968 <encode+0x258> sw $4,28($30)
00400970 <encode+0x260> lw $2,0($2)
00400978 <encode+0x268> lw $3,0($3)
00400980 <encode+0x270> mult $2,$3
00400988 <encode+0x278> mflo $2
00400990 <encode+0x280> lw $3,40($30)
00400998 <encode+0x288> addu $2,$3,$2
004009a0 <encode+0x290> sw $2,40($30)
../benchmarks/adpcm/adpcm.c:343
    xb += (long)(*tqmf_ptr) * (*h_ptr++);
004009a8 <encode+0x298> lw $2,32($30)
004009b0 <encode+0x2a0> lw $3,28($30)
004009b8 <encode+0x2a8> addiu $4,$3,4
004009c0 <encode+0x2b0> sw $4,28($30)
004009c8 <encode+0x2b8> lw $2,0($2)
004009d0 <encode+0x2c0> lw $3,0($3)
004009d8 <encode+0x2c8> mult $2,$3
004009e0 <encode+0x2d0> mflo $2
004009e8 <encode+0x2d8> lw $3,44($30)
004009f0 <encode+0x2e0> addu $2,$3,$2
004009f8 <encode+0x2e8> sw $2,44($30)
../benchmarks/adpcm/adpcm.c:346

/* update delay line tqmf */
    tqmf_ptr1 = tqmf_ptr - 2;
00400a00 <encode+0x2f0> lw $2,32($30)
00400a08 <encode+0x2f8> addiu $3,$2,-8
00400a10 <encode+0x300> sw $3,36($30)
../benchmarks/adpcm/adpcm.c:348
    /* MAX: 22 */
    for(i = 0 ; i < 22 ; i++) *tqmf_ptr-- = *tqmf_ptr1--;
00400a18 <encode+0x308> sw $0,24($30)
00400a20 <encode+0x310> lw $2,24($30)
00400a28 <encode+0x318> slti $3,$2,22
00400a30 <encode+0x320> bne $3,$0,00400a40 <encode+0x330>
00400a38 <encode+0x328> j 00400aa8 <encode+0x398>
00400a40 <encode+0x330> lw $2,32($30)
00400a48 <encode+0x338> addiu $3,$2,-4
00400a50 <encode+0x340> sw $3,32($30)
00400a58 <encode+0x348> lw $3,36($30)
00400a60 <encode+0x350> addiu $4,$3,-4
00400a68 <encode+0x358> sw $4,36($30)
00400a70 <encode+0x360> lw $3,0($3)
00400a78 <encode+0x368> sw $3,0($2)
00400a80 <encode+0x370> lw $3,24($30)
00400a88 <encode+0x378> addiu $2,$3,1
00400a90 <encode+0x380> addu $3,$0,$2
00400a98 <encode+0x388> sw $3,24($30)
00400aa0 <encode+0x390> j 00400a20 <encode+0x310>
../benchmarks/adpcm/adpcm.c:349
    *tqmf_ptr-- = xin1;
00400aa8 <encode+0x398> lw $2,32($30)
00400ab0 <encode+0x3a0> addiu $3,$2,-4
00400ab8 <encode+0x3a8> sw $3,32($30)
00400ac0 <encode+0x3b0> lw $3,64($30)
00400ac8 <encode+0x3b8> sw $3,0($2)
../benchmarks/adpcm/adpcm.c:350
    *tqmf_ptr = xin2;
00400ad0 <encode+0x3c0> lw $2,32($30)
00400ad8 <encode+0x3c8> lw $3,68($30)
00400ae0 <encode+0x3d0> sw $3,0($2)
../benchmarks/adpcm/adpcm.c:353

/* scale outputs */
    xl = (xa + xb) >> 15;
00400ae8 <encode+0x3d8> lw $2,40($30)
00400af0 <encode+0x3e0> lw $3,44($30)
00400af8 <encode+0x3e8> addu $2,$2,$3
00400b00 <encode+0x3f0> sra $3,$2,0xf
00400b08 <encode+0x3f8> sw $3,-32360($28)
../benchmarks/adpcm/adpcm.c:354
    xh = (xa - xb) >> 15;
00400b10 <encode+0x400> lw $2,40($30)
00400b18 <encode+0x408> lw $3,44($30)
00400b20 <encode+0x410> subu $2,$2,$3
00400b28 <encode+0x418> sra $3,$2,0xf
00400b30 <encode+0x420> sw $3,-32496($28)
../benchmarks/adpcm/adpcm.c:361

/* end of quadrature mirror filter code */

/* starting with lower sub band encoder */

/* filtez - compute predictor output section - zero section */
    szl = filtez(delay_bpl,delay_dltx);
00400b38 <encode+0x428> lui $4,4096
00400b40 <encode+0x430> addiu $4,$4,2832
00400b48 <encode+0x438> lui $5,4096
00400b50 <encode+0x440> addiu $5,$5,2480
00400b58 <encode+0x448> jal 00402020 <filtez>
00400b60 <encode+0x450> sw $2,-32532($28)
../benchmarks/adpcm/adpcm.c:364

/* filtep - compute predictor output signal (pole section) */
    spl = filtep(rlt1,al1,rlt2,al2);
00400b68 <encode+0x458> lw $4,-32368($28)
00400b70 <encode+0x460> lw $5,-32344($28)
00400b78 <encode+0x468> lw $6,-32480($28)
00400b80 <encode+0x470> lw $7,-32384($28)
00400b88 <encode+0x478> jal 004021a0 <filtep>
00400b90 <encode+0x480> sw $2,-32612($28)
../benchmarks/adpcm/adpcm.c:367

/* compute the predictor output value in the lower sub_band encoder */
    sl = szl + spl;
00400b98 <encode+0x488> lw $2,-32532($28)
00400ba0 <encode+0x490> lw $3,-32612($28)
00400ba8 <encode+0x498> addu $2,$2,$3
00400bb0 <encode+0x4a0> sw $2,-32544($28)
../benchmarks/adpcm/adpcm.c:368
    el = xl - sl;
00400bb8 <encode+0x4a8> lw $2,-32360($28)
00400bc0 <encode+0x4b0> lw $3,-32544($28)
00400bc8 <encode+0x4b8> subu $2,$2,$3
00400bd0 <encode+0x4c0> sw $2,-32456($28)
../benchmarks/adpcm/adpcm.c:371

/* quantl: quantize the difference signal */
    il = quantl(el,detl);
00400bd8 <encode+0x4c8> lw $4,-32456($28)
00400be0 <encode+0x4d0> lw $5,-32564($28)
00400be8 <encode+0x4d8> jal 004022b8 <quantl>
00400bf0 <encode+0x4e0> sw $2,-32464($28)
../benchmarks/adpcm/adpcm.c:375

/* invqxl: computes quantized difference signal */
/* for invqbl, truncate by 2 lsbs, so mode = 3 */
    dlt = ((long)detl*qq4_code4_table[il >> 2]) >> 15;
00400bf8 <encode+0x4e8> lw $3,-32464($28)
00400c00 <encode+0x4f0> sra $2,$3,0x2
00400c08 <encode+0x4f8> addu $3,$0,$2
00400c10 <encode+0x500> sll $2,$3,0x2
00400c18 <encode+0x508> lui $3,4096
00400c20 <encode+0x510> addiu $3,$3,192
00400c28 <encode+0x518> addu $2,$2,$3
00400c30 <encode+0x520> lw $3,-32564($28)
00400c38 <encode+0x528> lw $4,0($2)
00400c40 <encode+0x530> mult $3,$4
00400c48 <encode+0x538> mflo $2
00400c50 <encode+0x540> sra $3,$2,0xf
00400c58 <encode+0x548> sw $3,-32432($28)
../benchmarks/adpcm/adpcm.c:378

/* logscl: updates logarithmic quant. scale factor in low sub band */
    nbl = logscl(il,nbl);
00400c60 <encode+0x550> lw $4,-32464($28)
00400c68 <encode+0x558> lw $5,-32592($28)
00400c70 <encode+0x560> jal 004024a8 <logscl>
00400c78 <encode+0x568> sw $2,-32592($28)
../benchmarks/adpcm/adpcm.c:382

/* scalel: compute the quantizer scale factor in the lower sub band */
/* calling parameters nbl and 8 (constant such that scalel can be scaleh) */
    detl = scalel(nbl,8);
00400c80 <encode+0x570> lw $4,-32592($28)
00400c88 <encode+0x578> addiu $5,$0,8
00400c90 <encode+0x580> jal 004025c8 <scalel>
00400c98 <encode+0x588> sw $2,-32564($28)
../benchmarks/adpcm/adpcm.c:385

/* parrec - simple addition to compute recontructed signal for adaptive pred */
    plt = dlt + szl;
00400ca0 <encode+0x590> lw $2,-32432($28)
00400ca8 <encode+0x598> lw $3,-32532($28)
00400cb0 <encode+0x5a0> addu $2,$2,$3
00400cb8 <encode+0x5a8> sw $2,-32356($28)
../benchmarks/adpcm/adpcm.c:391

/* upzero: update zero section predictor coefficients (sixth order)*/
/* calling parameters: dlt, dlt1, dlt2, ..., dlt6 from dlt */
/*  bpli (linear_buffer in which all six values are delayed */
/* return params:      updated bpli, delayed dltx */
    upzero(dlt,delay_dltx,delay_bpl);
00400cc0 <encode+0x5b0> lw $4,-32432($28)
00400cc8 <encode+0x5b8> lui $5,4096
00400cd0 <encode+0x5c0> addiu $5,$5,2480
00400cd8 <encode+0x5c8> lui $6,4096
00400ce0 <encode+0x5d0> addiu $6,$6,2832
00400ce8 <encode+0x5d8> jal 004026d0 <upzero>
../benchmarks/adpcm/adpcm.c:395

/* uppol2- update second predictor coefficient apl2 and delay it as al2 */
/* calling parameters: al1, al2, plt, plt1, plt2 */
    al2 = uppol2(al1,al2,plt,plt1,plt2);
00400cf0 <encode+0x5e0> lw $2,-32408($28)
00400cf8 <encode+0x5e8> sw $2,16($29)
00400d00 <encode+0x5f0> lw $4,-32344($28)
00400d08 <encode+0x5f8> lw $5,-32384($28)
00400d10 <encode+0x600> lw $6,-32356($28)
00400d18 <encode+0x608> lw $7,-32396($28)
00400d20 <encode+0x610> jal 00402a48 <uppol2>
00400d28 <encode+0x618> sw $2,-32384($28)
../benchmarks/adpcm/adpcm.c:399

/* uppol1 :update first predictor coefficient apl1 and delay it as al1 */
/* calling parameters: al1, apl2, plt, plt1 */
    al1 = uppol1(al1,al2,plt,plt1);
00400d30 <encode+0x620> lw $4,-32344($28)
00400d38 <encode+0x628> lw $5,-32384($28)
00400d40 <encode+0x630> lw $6,-32356($28)
00400d48 <encode+0x638> lw $7,-32396($28)
00400d50 <encode+0x640> jal 00402c18 <uppol1>
00400d58 <encode+0x648> sw $2,-32344($28)
../benchmarks/adpcm/adpcm.c:402

/* recons : compute recontructed signal for adaptive predictor */
    rlt = sl + dlt;
00400d60 <encode+0x650> lw $2,-32544($28)
00400d68 <encode+0x658> lw $3,-32432($28)
00400d70 <encode+0x660> addu $2,$2,$3
00400d78 <encode+0x668> sw $2,-32548($28)
../benchmarks/adpcm/adpcm.c:405

/* done with lower sub_band encoder; now implement delays for next time*/
    rlt2 = rlt1;
00400d80 <encode+0x670> lw $2,-32368($28)
00400d88 <encode+0x678> sw $2,-32480($28)
../benchmarks/adpcm/adpcm.c:406
    rlt1 = rlt;
00400d90 <encode+0x680> lw $2,-32548($28)
00400d98 <encode+0x688> sw $2,-32368($28)
../benchmarks/adpcm/adpcm.c:407
    plt2 = plt1;
00400da0 <encode+0x690> lw $2,-32396($28)
00400da8 <encode+0x698> sw $2,-32408($28)
../benchmarks/adpcm/adpcm.c:408
    plt1 = plt;
00400db0 <encode+0x6a0> lw $2,-32356($28)
00400db8 <encode+0x6a8> sw $2,-32396($28)
../benchmarks/adpcm/adpcm.c:412

/* high band encode */

    szh = filtez(delay_bph,delay_dhx);
00400dc0 <encode+0x6b0> lui $4,4096
00400dc8 <encode+0x6b8> addiu $4,$4,2896
00400dd0 <encode+0x6c0> lui $5,4096
00400dd8 <encode+0x6c8> addiu $5,$5,2624
00400de0 <encode+0x6d0> jal 00402020 <filtez>
00400de8 <encode+0x6d8> sw $2,-32608($28)
../benchmarks/adpcm/adpcm.c:414

    sph = filtep(rh1,ah1,rh2,ah2);
00400df0 <encode+0x6e0> lw $4,-32420($28)
00400df8 <encode+0x6e8> lw $5,-32552($28)
00400e00 <encode+0x6f0> lw $6,-32616($28)
00400e08 <encode+0x6f8> lw $7,-32468($28)
00400e10 <encode+0x700> jal 004021a0 <filtep>
00400e18 <encode+0x708> sw $2,-32436($28)
../benchmarks/adpcm/adpcm.c:417

/* predic: sh = sph + szh */
    sh = sph + szh;
00400e20 <encode+0x710> lw $2,-32436($28)
00400e28 <encode+0x718> lw $3,-32608($28)
00400e30 <encode+0x720> addu $2,$2,$3
00400e38 <encode+0x728> sw $2,-32568($28)
../benchmarks/adpcm/adpcm.c:419
/* subtra: eh = xh - sh */
    eh = xh - sh;
00400e40 <encode+0x730> lw $2,-32496($28)
00400e48 <encode+0x738> lw $3,-32568($28)
00400e50 <encode+0x740> subu $2,$2,$3
00400e58 <encode+0x748> sw $2,-32560($28)
../benchmarks/adpcm/adpcm.c:423

/* quanth - quantization of difference signal for higher sub-band */
/* quanth: in-place for speed params: eh, deth (has init. value) */
    if(eh >= 0) {
00400e60 <encode+0x750> lw $2,-32560($28)
00400e68 <encode+0x758> bltz $2,00400e88 <encode+0x778>
../benchmarks/adpcm/adpcm.c:424
        ih = 3;     /* 2,3 are pos codes */
00400e70 <encode+0x760> addiu $2,$0,3
00400e78 <encode+0x768> sw $2,-32600($28)
../benchmarks/adpcm/adpcm.c:425
    }
00400e80 <encode+0x770> j 00400e98 <encode+0x788>
../benchmarks/adpcm/adpcm.c:427
    else {
        ih = 1;     /* 0,1 are neg codes */
00400e88 <encode+0x778> addiu $2,$0,1
00400e90 <encode+0x780> sw $2,-32600($28)
../benchmarks/adpcm/adpcm.c:429
    }
    decis = (564L*(long)deth) >> 12L;
00400e98 <encode+0x788> lw $2,-32508($28)
00400ea0 <encode+0x790> addu $4,$0,$2
00400ea8 <encode+0x798> sll $3,$4,0x3
00400eb0 <encode+0x7a0> addu $3,$3,$2
00400eb8 <encode+0x7a8> sll $4,$3,0x2
00400ec0 <encode+0x7b0> subu $4,$4,$2
00400ec8 <encode+0x7b8> sll $3,$4,0x2
00400ed0 <encode+0x7c0> addu $3,$3,$2
00400ed8 <encode+0x7c8> sll $2,$3,0x2
00400ee0 <encode+0x7d0> sra $3,$2,0xc
00400ee8 <encode+0x7d8> sw $3,48($30)
../benchmarks/adpcm/adpcm.c:430
    if(my_abs(eh) > decis) ih--;     /* mih = 2 case */
00400ef0 <encode+0x7e0> lw $4,-32560($28)
00400ef8 <encode+0x7e8> jal 004001f0 <my_abs>
00400f00 <encode+0x7f0> lw $3,48($30)
00400f08 <encode+0x7f8> slt $2,$3,$2
00400f10 <encode+0x800> beq $2,$0,00400f38 <encode+0x828>
00400f18 <encode+0x808> lw $3,-32600($28)
00400f20 <encode+0x810> addiu $2,$3,-1
00400f28 <encode+0x818> addu $3,$0,$2
00400f30 <encode+0x820> sw $3,-32600($28)
../benchmarks/adpcm/adpcm.c:433

/* invqah: compute the quantized difference signal, higher sub-band*/
    dh = ((long)deth*qq2_code2_table[ih]) >> 15L ;
00400f38 <encode+0x828> lw $2,-32600($28)
00400f40 <encode+0x830> addu $3,$0,$2
00400f48 <encode+0x838> sll $2,$3,0x2
00400f50 <encode+0x840> lui $3,4096
00400f58 <encode+0x848> addiu $3,$3,1232
00400f60 <encode+0x850> addu $2,$2,$3
00400f68 <encode+0x858> lw $3,-32508($28)
00400f70 <encode+0x860> lw $4,0($2)
00400f78 <encode+0x868> mult $3,$4
00400f80 <encode+0x870> mflo $2
00400f88 <encode+0x878> sra $3,$2,0xf
00400f90 <encode+0x880> sw $3,-32576($28)
../benchmarks/adpcm/adpcm.c:436

/* logsch: update logarithmic quantizer scale factor in hi sub-band*/
    nbh = logsch(ih,nbh);
00400f98 <encode+0x888> lw $4,-32600($28)
00400fa0 <encode+0x890> lw $5,-32372($28)
00400fa8 <encode+0x898> jal 00402da0 <logsch>
00400fb0 <encode+0x8a0> sw $2,-32372($28)
../benchmarks/adpcm/adpcm.c:439

/* note : scalel and scaleh use same code, different parameters */
    deth = scalel(nbh,10);
00400fb8 <encode+0x8a8> lw $4,-32372($28)
00400fc0 <encode+0x8b0> addiu $5,$0,10
00400fc8 <encode+0x8b8> jal 004025c8 <scalel>
00400fd0 <encode+0x8c0> sw $2,-32508($28)
../benchmarks/adpcm/adpcm.c:442

/* parrec - add pole predictor output to quantized diff. signal */
    ph = dh + szh;
00400fd8 <encode+0x8c8> lw $2,-32576($28)
00400fe0 <encode+0x8d0> lw $3,-32608($28)
00400fe8 <encode+0x8d8> addu $2,$2,$3
00400ff0 <encode+0x8e0> sw $2,-32580($28)
../benchmarks/adpcm/adpcm.c:447

/* upzero: update zero section predictor coefficients (sixth order) */
/* calling parameters: dh, dhi, bphi */
/* return params: updated bphi, delayed dhx */
    upzero(dh,delay_dhx,delay_bph);
00400ff8 <encode+0x8e8> lw $4,-32576($28)
00401000 <encode+0x8f0> lui $5,4096
00401008 <encode+0x8f8> addiu $5,$5,2624
00401010 <encode+0x900> lui $6,4096
00401018 <encode+0x908> addiu $6,$6,2896
00401020 <encode+0x910> jal 004026d0 <upzero>
../benchmarks/adpcm/adpcm.c:451

/* uppol2: update second predictor coef aph2 and delay as ah2 */
/* calling params: ah1, ah2, ph, ph1, ph2 */
    ah2 = uppol2(ah1,ah2,ph,ph1,ph2);
00401028 <encode+0x918> lw $2,-32476($28)
00401030 <encode+0x920> sw $2,16($29)
00401038 <encode+0x928> lw $4,-32552($28)
00401040 <encode+0x930> lw $5,-32468($28)
00401048 <encode+0x938> lw $6,-32580($28)
00401050 <encode+0x940> lw $7,-32424($28)
00401058 <encode+0x948> jal 00402a48 <uppol2>
00401060 <encode+0x950> sw $2,-32468($28)
../benchmarks/adpcm/adpcm.c:454

/* uppol1:  update first predictor coef. aph2 and delay it as ah1 */
    ah1 = uppol1(ah1,ah2,ph,ph1);
00401068 <encode+0x958> lw $4,-32552($28)
00401070 <encode+0x960> lw $5,-32468($28)
00401078 <encode+0x968> lw $6,-32580($28)
00401080 <encode+0x970> lw $7,-32424($28)
00401088 <encode+0x978> jal 00402c18 <uppol1>
00401090 <encode+0x980> sw $2,-32552($28)
../benchmarks/adpcm/adpcm.c:457

/* recons for higher sub-band */
    yh = sh + dh;
00401098 <encode+0x988> lw $2,-32568($28)
004010a0 <encode+0x990> lw $3,-32576($28)
004010a8 <encode+0x998> addu $2,$2,$3
004010b0 <encode+0x9a0> sw $2,-32556($28)
../benchmarks/adpcm/adpcm.c:460

/* done with higher sub-band encoder, now Delay for next time */
    rh2 = rh1;
004010b8 <encode+0x9a8> lw $2,-32420($28)
004010c0 <encode+0x9b0> sw $2,-32616($28)
../benchmarks/adpcm/adpcm.c:461
    rh1 = yh;
004010c8 <encode+0x9b8> lw $2,-32556($28)
004010d0 <encode+0x9c0> sw $2,-32420($28)
../benchmarks/adpcm/adpcm.c:462
    ph2 = ph1;
004010d8 <encode+0x9c8> lw $2,-32424($28)
004010e0 <encode+0x9d0> sw $2,-32476($28)
../benchmarks/adpcm/adpcm.c:463
    ph1 = ph;
004010e8 <encode+0x9d8> lw $2,-32580($28)
004010f0 <encode+0x9e0> sw $2,-32424($28)
../benchmarks/adpcm/adpcm.c:466

/* multiplex ih and il to get signals together */
    return(il | (ih << 6));
004010f8 <encode+0x9e8> lw $3,-32600($28)
00401100 <encode+0x9f0> sll $2,$3,0x6
00401108 <encode+0x9f8> lw $4,-32464($28)
00401110 <encode+0xa00> or $3,$2,$4
00401118 <encode+0xa08> addu $2,$0,$3
00401120 <encode+0xa10> j 00401128 <encode+0xa18>
../benchmarks/adpcm/adpcm.c:467
}
00401128 <encode+0xa18> addu $29,$0,$30
00401130 <encode+0xa20> lw $31,60($29)
00401138 <encode+0xa28> lw $30,56($29)
00401140 <encode+0xa30> addiu $29,$29,64
00401148 <encode+0xa38> jr $31
decode():
../benchmarks/adpcm/adpcm.c:472

/* decode function, result in xout1 and xout2 */

void decode(int input)
{
00401150 <decode> addiu $29,$29,-64
00401158 <decode+0x8> sw $31,60($29)
00401160 <decode+0x10> sw $30,56($29)
00401168 <decode+0x18> addu $30,$0,$29
00401170 <decode+0x20> sw $4,64($30)
../benchmarks/adpcm/adpcm.c:478
    int i;
    long int xa1,xa2;    /* qmf accumulators */
    int *h_ptr,*ac_ptr,*ac_ptr1,*ad_ptr,*ad_ptr1;

/* split transmitted word from input into ilr and ih */
    ilr = input & 0x3f;
00401178 <decode+0x28> lw $2,64($30)
00401180 <decode+0x30> andi $3,$2,63
00401188 <decode+0x38> sw $3,-32460($28)
../benchmarks/adpcm/adpcm.c:479
    ih = input >> 6;
00401190 <decode+0x40> lw $2,64($30)
00401198 <decode+0x48> sra $3,$2,0x6
004011a0 <decode+0x50> sw $3,-32600($28)
../benchmarks/adpcm/adpcm.c:484

/* LOWER SUB_BAND DECODER */

/* filtez: compute predictor output for zero section */
    dec_szl = filtez(dec_del_bpl,dec_del_dltx);
004011a8 <decode+0x58> lui $4,4096
004011b0 <decode+0x60> addiu $4,$4,2864
004011b8 <decode+0x68> lui $5,4096
004011c0 <decode+0x70> addiu $5,$5,2512
004011c8 <decode+0x78> jal 00402020 <filtez>
004011d0 <decode+0x80> sw $2,-32520($28)
../benchmarks/adpcm/adpcm.c:487

/* filtep: compute predictor output signal for pole section */
    dec_spl = filtep(dec_rlt1,dec_al1,dec_rlt2,dec_al2);
004011d8 <decode+0x88> lw $4,-32500($28)
004011e0 <decode+0x90> lw $5,-32364($28)
004011e8 <decode+0x98> lw $6,-32504($28)
004011f0 <decode+0xa0> lw $7,-32400($28)
004011f8 <decode+0xa8> jal 004021a0 <filtep>
00401200 <decode+0xb0> sw $2,-32452($28)
../benchmarks/adpcm/adpcm.c:489

    dec_sl = dec_spl + dec_szl;
00401208 <decode+0xb8> lw $2,-32452($28)
00401210 <decode+0xc0> lw $3,-32520($28)
00401218 <decode+0xc8> addu $2,$2,$3
00401220 <decode+0xd0> sw $2,-32492($28)
../benchmarks/adpcm/adpcm.c:492

/* invqxl: compute quantized difference signal for adaptive predic */
    dec_dlt = ((long)dec_detl*qq4_code4_table[ilr >> 2]) >> 15;
00401228 <decode+0xd8> lw $3,-32460($28)
00401230 <decode+0xe0> sra $2,$3,0x2
00401238 <decode+0xe8> addu $3,$0,$2
00401240 <decode+0xf0> sll $2,$3,0x2
00401248 <decode+0xf8> lui $3,4096
00401250 <decode+0x100> addiu $3,$3,192
00401258 <decode+0x108> addu $2,$2,$3
00401260 <decode+0x110> lw $3,-32404($28)
00401268 <decode+0x118> lw $4,0($2)
00401270 <decode+0x120> mult $3,$4
00401278 <decode+0x128> mflo $2
00401280 <decode+0x130> sra $3,$2,0xf
00401288 <decode+0x138> sw $3,-32472($28)
../benchmarks/adpcm/adpcm.c:495

/* invqxl: compute quantized difference signal for decoder output */
    dl = ((long)dec_detl*qq6_code6_table[il]) >> 15;
00401290 <decode+0x140> lw $2,-32464($28)
00401298 <decode+0x148> addu $3,$0,$2
004012a0 <decode+0x150> sll $2,$3,0x2
004012a8 <decode+0x158> lui $3,4096
004012b0 <decode+0x160> addiu $3,$3,384
004012b8 <decode+0x168> addu $2,$2,$3
004012c0 <decode+0x170> lw $3,-32404($28)
004012c8 <decode+0x178> lw $4,0($2)
004012d0 <decode+0x180> mult $3,$4
004012d8 <decode+0x188> mflo $2
004012e0 <decode+0x190> sra $3,$2,0xf
004012e8 <decode+0x198> sw $3,-32428($28)
../benchmarks/adpcm/adpcm.c:497

    rl = dl + dec_sl;
004012f0 <decode+0x1a0> lw $2,-32428($28)
004012f8 <decode+0x1a8> lw $3,-32492($28)
00401300 <decode+0x1b0> addu $2,$2,$3
00401308 <decode+0x1b8> sw $2,-32624($28)
../benchmarks/adpcm/adpcm.c:500

/* logscl: quantizer scale factor adaptation in the lower sub-band */
    dec_nbl = logscl(ilr,dec_nbl);
00401310 <decode+0x1c0> lw $4,-32460($28)
00401318 <decode+0x1c8> lw $5,-32444($28)
00401320 <decode+0x1d0> jal 004024a8 <logscl>
00401328 <decode+0x1d8> sw $2,-32444($28)
../benchmarks/adpcm/adpcm.c:503

/* scalel: computes quantizer scale factor in the lower sub band */
    dec_detl = scalel(dec_nbl,8);
00401330 <decode+0x1e0> lw $4,-32444($28)
00401338 <decode+0x1e8> addiu $5,$0,8
00401340 <decode+0x1f0> jal 004025c8 <scalel>
00401348 <decode+0x1f8> sw $2,-32404($28)
../benchmarks/adpcm/adpcm.c:507

/* parrec - add pole predictor output to quantized diff. signal */
/* for partially reconstructed signal */
    dec_plt = dec_dlt + dec_szl;
00401350 <decode+0x200> lw $2,-32472($28)
00401358 <decode+0x208> lw $3,-32520($28)
00401360 <decode+0x210> addu $2,$2,$3
00401368 <decode+0x218> sw $2,-32392($28)
../benchmarks/adpcm/adpcm.c:510

/* upzero: update zero section predictor coefficients */
    upzero(dec_dlt,dec_del_dltx,dec_del_bpl);
00401370 <decode+0x220> lw $4,-32472($28)
00401378 <decode+0x228> lui $5,4096
00401380 <decode+0x230> addiu $5,$5,2512
00401388 <decode+0x238> lui $6,4096
00401390 <decode+0x240> addiu $6,$6,2864
00401398 <decode+0x248> jal 004026d0 <upzero>
../benchmarks/adpcm/adpcm.c:513

/* uppol2: update second predictor coefficient apl2 and delay it as al2 */
    dec_al2 = uppol2(dec_al1,dec_al2,dec_plt,dec_plt1,dec_plt2);
004013a0 <decode+0x250> lw $2,-32620($28)
004013a8 <decode+0x258> sw $2,16($29)
004013b0 <decode+0x260> lw $4,-32364($28)
004013b8 <decode+0x268> lw $5,-32400($28)
004013c0 <decode+0x270> lw $6,-32392($28)
004013c8 <decode+0x278> lw $7,-32596($28)
004013d0 <decode+0x280> jal 00402a48 <uppol2>
004013d8 <decode+0x288> sw $2,-32400($28)
../benchmarks/adpcm/adpcm.c:516

/* uppol1: update first predictor coef. (pole setion) */
    dec_al1 = uppol1(dec_al1,dec_al2,dec_plt,dec_plt1);
004013e0 <decode+0x290> lw $4,-32364($28)
004013e8 <decode+0x298> lw $5,-32400($28)
004013f0 <decode+0x2a0> lw $6,-32392($28)
004013f8 <decode+0x2a8> lw $7,-32596($28)
00401400 <decode+0x2b0> jal 00402c18 <uppol1>
00401408 <decode+0x2b8> sw $2,-32364($28)
../benchmarks/adpcm/adpcm.c:519

/* recons : compute recontructed signal for adaptive predictor */
    dec_rlt = dec_sl + dec_dlt;
00401410 <decode+0x2c0> lw $2,-32492($28)
00401418 <decode+0x2c8> lw $3,-32472($28)
00401420 <decode+0x2d0> addu $2,$2,$3
00401428 <decode+0x2d8> sw $2,-32604($28)
../benchmarks/adpcm/adpcm.c:522

/* done with lower sub band decoder, implement delays for next time */
    dec_rlt2 = dec_rlt1;
00401430 <decode+0x2e0> lw $2,-32500($28)
00401438 <decode+0x2e8> sw $2,-32504($28)
../benchmarks/adpcm/adpcm.c:523
    dec_rlt1 = dec_rlt;
00401440 <decode+0x2f0> lw $2,-32604($28)
00401448 <decode+0x2f8> sw $2,-32500($28)
../benchmarks/adpcm/adpcm.c:524
    dec_plt2 = dec_plt1;
00401450 <decode+0x300> lw $2,-32596($28)
00401458 <decode+0x308> sw $2,-32620($28)
../benchmarks/adpcm/adpcm.c:525
    dec_plt1 = dec_plt;
00401460 <decode+0x310> lw $2,-32392($28)
00401468 <decode+0x318> sw $2,-32596($28)
../benchmarks/adpcm/adpcm.c:530

/* HIGH SUB-BAND DECODER */

/* filtez: compute predictor output for zero section */
    dec_szh = filtez(dec_del_bph,dec_del_dhx);
00401470 <decode+0x320> lui $4,4096
00401478 <decode+0x328> addiu $4,$4,2752
00401480 <decode+0x330> lui $5,4096
00401488 <decode+0x338> addiu $5,$5,2592
00401490 <decode+0x340> jal 00402020 <filtez>
00401498 <decode+0x348> sw $2,-32448($28)
../benchmarks/adpcm/adpcm.c:533

/* filtep: compute predictor output signal for pole section */
    dec_sph = filtep(dec_rh1,dec_ah1,dec_rh2,dec_ah2);
004014a0 <decode+0x350> lw $4,-32380($28)
004014a8 <decode+0x358> lw $5,-32524($28)
004014b0 <decode+0x360> lw $6,-32388($28)
004014b8 <decode+0x368> lw $7,-32352($28)
004014c0 <decode+0x370> jal 004021a0 <filtep>
004014c8 <decode+0x378> sw $2,-32572($28)
../benchmarks/adpcm/adpcm.c:536

/* predic:compute the predictor output value in the higher sub_band decoder */
    dec_sh = dec_sph + dec_szh;
004014d0 <decode+0x380> lw $2,-32572($28)
004014d8 <decode+0x388> lw $3,-32448($28)
004014e0 <decode+0x390> addu $2,$2,$3
004014e8 <decode+0x398> sw $2,-32416($28)
../benchmarks/adpcm/adpcm.c:539

/* invqah: in-place compute the quantized difference signal */
    dec_dh = ((long)dec_deth*qq2_code2_table[ih]) >> 15L ;
004014f0 <decode+0x3a0> lw $2,-32600($28)
004014f8 <decode+0x3a8> addu $3,$0,$2
00401500 <decode+0x3b0> sll $2,$3,0x2
00401508 <decode+0x3b8> lui $3,4096
00401510 <decode+0x3c0> addiu $3,$3,1232
00401518 <decode+0x3c8> addu $2,$2,$3
00401520 <decode+0x3d0> lw $3,-32484($28)
00401528 <decode+0x3d8> lw $4,0($2)
00401530 <decode+0x3e0> mult $3,$4
00401538 <decode+0x3e8> mflo $2
00401540 <decode+0x3f0> sra $3,$2,0xf
00401548 <decode+0x3f8> sw $3,-32516($28)
../benchmarks/adpcm/adpcm.c:542

/* logsch: update logarithmic quantizer scale factor in hi sub band */
    dec_nbh = logsch(ih,dec_nbh);
00401550 <decode+0x400> lw $4,-32600($28)
00401558 <decode+0x408> lw $5,-32588($28)
00401560 <decode+0x410> jal 00402da0 <logsch>
00401568 <decode+0x418> sw $2,-32588($28)
../benchmarks/adpcm/adpcm.c:545

/* scalel: compute the quantizer scale factor in the higher sub band */
    dec_deth = scalel(dec_nbh,10);
00401570 <decode+0x420> lw $4,-32588($28)
00401578 <decode+0x428> addiu $5,$0,10
00401580 <decode+0x430> jal 004025c8 <scalel>
00401588 <decode+0x438> sw $2,-32484($28)
../benchmarks/adpcm/adpcm.c:548

/* parrec: compute partially recontructed signal */
    dec_ph = dec_dh + dec_szh;
00401590 <decode+0x440> lw $2,-32516($28)
00401598 <decode+0x448> lw $3,-32448($28)
004015a0 <decode+0x450> addu $2,$2,$3
004015a8 <decode+0x458> sw $2,-32440($28)
../benchmarks/adpcm/adpcm.c:551

/* upzero: update zero section predictor coefficients */
    upzero(dec_dh,dec_del_dhx,dec_del_bph);
004015b0 <decode+0x460> lw $4,-32516($28)
004015b8 <decode+0x468> lui $5,4096
004015c0 <decode+0x470> addiu $5,$5,2592
004015c8 <decode+0x478> lui $6,4096
004015d0 <decode+0x480> addiu $6,$6,2752
004015d8 <decode+0x488> jal 004026d0 <upzero>
../benchmarks/adpcm/adpcm.c:554

/* uppol2: update second predictor coefficient aph2 and delay it as ah2 */
    dec_ah2 = uppol2(dec_ah1,dec_ah2,dec_ph,dec_ph1,dec_ph2);
004015e0 <decode+0x490> lw $2,-32528($28)
004015e8 <decode+0x498> sw $2,16($29)
004015f0 <decode+0x4a0> lw $4,-32524($28)
004015f8 <decode+0x4a8> lw $5,-32352($28)
00401600 <decode+0x4b0> lw $6,-32440($28)
00401608 <decode+0x4b8> lw $7,-32584($28)
00401610 <decode+0x4c0> jal 00402a48 <uppol2>
00401618 <decode+0x4c8> sw $2,-32352($28)
../benchmarks/adpcm/adpcm.c:557

/* uppol1: update first predictor coef. (pole setion) */
    dec_ah1 = uppol1(dec_ah1,dec_ah2,dec_ph,dec_ph1);
00401620 <decode+0x4d0> lw $4,-32524($28)
00401628 <decode+0x4d8> lw $5,-32352($28)
00401630 <decode+0x4e0> lw $6,-32440($28)
00401638 <decode+0x4e8> lw $7,-32584($28)
00401640 <decode+0x4f0> jal 00402c18 <uppol1>
00401648 <decode+0x4f8> sw $2,-32524($28)
../benchmarks/adpcm/adpcm.c:560

/* recons : compute recontructed signal for adaptive predictor */
    rh = dec_sh + dec_dh;
00401650 <decode+0x500> lw $2,-32416($28)
00401658 <decode+0x508> lw $3,-32516($28)
00401660 <decode+0x510> addu $2,$2,$3
00401668 <decode+0x518> sw $2,-32512($28)
../benchmarks/adpcm/adpcm.c:563

/* done with high band decode, implementing delays for next time here */
    dec_rh2 = dec_rh1;
00401670 <decode+0x520> lw $2,-32380($28)
00401678 <decode+0x528> sw $2,-32388($28)
../benchmarks/adpcm/adpcm.c:564
    dec_rh1 = rh;
00401680 <decode+0x530> lw $2,-32512($28)
00401688 <decode+0x538> sw $2,-32380($28)
../benchmarks/adpcm/adpcm.c:565
    dec_ph2 = dec_ph1;
00401690 <decode+0x540> lw $2,-32584($28)
00401698 <decode+0x548> sw $2,-32528($28)
../benchmarks/adpcm/adpcm.c:566
    dec_ph1 = dec_ph;
004016a0 <decode+0x550> lw $2,-32440($28)
004016a8 <decode+0x558> sw $2,-32584($28)
../benchmarks/adpcm/adpcm.c:571

/* end of higher sub_band decoder */

/* end with receive quadrature mirror filters */
    xd = rl - rh;
004016b0 <decode+0x560> lw $2,-32624($28)
004016b8 <decode+0x568> lw $3,-32512($28)
004016c0 <decode+0x570> subu $2,$2,$3
004016c8 <decode+0x578> sw $2,-32412($28)
../benchmarks/adpcm/adpcm.c:572
    xs = rl + rh;
004016d0 <decode+0x580> lw $2,-32624($28)
004016d8 <decode+0x588> lw $3,-32512($28)
004016e0 <decode+0x590> addu $2,$2,$3
004016e8 <decode+0x598> sw $2,-32348($28)
../benchmarks/adpcm/adpcm.c:575

/* receive quadrature mirror filters implemented here */
    h_ptr = h;
004016f0 <decode+0x5a0> lui $2,4096
004016f8 <decode+0x5a8> addiu $2,$2,96
00401700 <decode+0x5b0> sw $2,36($30)
../benchmarks/adpcm/adpcm.c:576
    ac_ptr = accumc;
00401708 <decode+0x5b8> lui $2,4096
00401710 <decode+0x5c0> addiu $2,$2,2784
00401718 <decode+0x5c8> sw $2,40($30)
../benchmarks/adpcm/adpcm.c:577
    ad_ptr = accumd;
00401720 <decode+0x5d0> lui $2,4096
00401728 <decode+0x5d8> addiu $2,$2,2544
00401730 <decode+0x5e0> sw $2,48($30)
../benchmarks/adpcm/adpcm.c:578
    xa1 = (long)xd * (*h_ptr++);
00401738 <decode+0x5e8> lw $2,36($30)
00401740 <decode+0x5f0> addiu $3,$2,4
00401748 <decode+0x5f8> sw $3,36($30)
00401750 <decode+0x600> lw $3,-32412($28)
00401758 <decode+0x608> lw $2,0($2)
00401760 <decode+0x610> mult $3,$2
00401768 <decode+0x618> mflo $3
00401770 <decode+0x620> sw $3,28($30)
../benchmarks/adpcm/adpcm.c:579
    xa2 = (long)xs * (*h_ptr++);
00401778 <decode+0x628> lw $2,36($30)
00401780 <decode+0x630> addiu $3,$2,4
00401788 <decode+0x638> sw $3,36($30)
00401790 <decode+0x640> lw $3,-32348($28)
00401798 <decode+0x648> lw $2,0($2)
004017a0 <decode+0x650> mult $3,$2
004017a8 <decode+0x658> mflo $3
004017b0 <decode+0x660> sw $3,32($30)
../benchmarks/adpcm/adpcm.c:581
/* main multiply accumulate loop for samples and coefficients */
    for(i = 0 ; i < 10 ; i++) {
004017b8 <decode+0x668> sw $0,24($30)
004017c0 <decode+0x670> lw $2,24($30)
004017c8 <decode+0x678> slti $3,$2,10
004017d0 <decode+0x680> bne $3,$0,004017e0 <decode+0x690>
004017d8 <decode+0x688> j 004018d8 <decode+0x788>
../benchmarks/adpcm/adpcm.c:582
        xa1 += (long)(*ac_ptr++) * (*h_ptr++);
004017e0 <decode+0x690> lw $2,40($30)
004017e8 <decode+0x698> addiu $3,$2,4
004017f0 <decode+0x6a0> sw $3,40($30)
004017f8 <decode+0x6a8> lw $3,36($30)
00401800 <decode+0x6b0> addiu $4,$3,4
00401808 <decode+0x6b8> sw $4,36($30)
00401810 <decode+0x6c0> lw $2,0($2)
00401818 <decode+0x6c8> lw $3,0($3)
00401820 <decode+0x6d0> mult $2,$3
00401828 <decode+0x6d8> mflo $2
00401830 <decode+0x6e0> lw $3,28($30)
00401838 <decode+0x6e8> addu $2,$3,$2
00401840 <decode+0x6f0> sw $2,28($30)
../benchmarks/adpcm/adpcm.c:583
        xa2 += (long)(*ad_ptr++) * (*h_ptr++);
00401848 <decode+0x6f8> lw $2,48($30)
00401850 <decode+0x700> addiu $3,$2,4
00401858 <decode+0x708> sw $3,48($30)
00401860 <decode+0x710> lw $3,36($30)
00401868 <decode+0x718> addiu $4,$3,4
00401870 <decode+0x720> sw $4,36($30)
00401878 <decode+0x728> lw $2,0($2)
00401880 <decode+0x730> lw $3,0($3)
00401888 <decode+0x738> mult $2,$3
00401890 <decode+0x740> mflo $2
00401898 <decode+0x748> lw $3,32($30)
004018a0 <decode+0x750> addu $2,$3,$2
004018a8 <decode+0x758> sw $2,32($30)
../benchmarks/adpcm/adpcm.c:581
004018b0 <decode+0x760> lw $3,24($30)
004018b8 <decode+0x768> addiu $2,$3,1
004018c0 <decode+0x770> addu $3,$0,$2
004018c8 <decode+0x778> sw $3,24($30)
004018d0 <decode+0x780> j 004017c0 <decode+0x670>
../benchmarks/adpcm/adpcm.c:586
    }
/* final mult/accumulate */
    xa1 += (long)(*ac_ptr) * (*h_ptr++);
004018d8 <decode+0x788> lw $2,40($30)
004018e0 <decode+0x790> lw $3,36($30)
004018e8 <decode+0x798> addiu $4,$3,4
004018f0 <decode+0x7a0> sw $4,36($30)
004018f8 <decode+0x7a8> lw $2,0($2)
00401900 <decode+0x7b0> lw $3,0($3)
00401908 <decode+0x7b8> mult $2,$3
00401910 <decode+0x7c0> mflo $2
00401918 <decode+0x7c8> lw $3,28($30)
00401920 <decode+0x7d0> addu $2,$3,$2
00401928 <decode+0x7d8> sw $2,28($30)
../benchmarks/adpcm/adpcm.c:587
    xa2 += (long)(*ad_ptr) * (*h_ptr++);
00401930 <decode+0x7e0> lw $2,48($30)
00401938 <decode+0x7e8> lw $3,36($30)
00401940 <decode+0x7f0> addiu $4,$3,4
00401948 <decode+0x7f8> sw $4,36($30)
00401950 <decode+0x800> lw $2,0($2)
00401958 <decode+0x808> lw $3,0($3)
00401960 <decode+0x810> mult $2,$3
00401968 <decode+0x818> mflo $2
00401970 <decode+0x820> lw $3,32($30)
00401978 <decode+0x828> addu $2,$3,$2
00401980 <decode+0x830> sw $2,32($30)
../benchmarks/adpcm/adpcm.c:590

/* scale by 2^14 */
    xout1 = xa1 >> 14;
00401988 <decode+0x838> lw $2,28($30)
00401990 <decode+0x840> sra $3,$2,0xe
00401998 <decode+0x848> sw $3,-32540($28)
../benchmarks/adpcm/adpcm.c:591
    xout2 = xa2 >> 14;
004019a0 <decode+0x850> lw $2,32($30)
004019a8 <decode+0x858> sra $3,$2,0xe
004019b0 <decode+0x860> sw $3,-32488($28)
../benchmarks/adpcm/adpcm.c:594

/* update delay lines */
    ac_ptr1 = ac_ptr - 1;
004019b8 <decode+0x868> lw $2,40($30)
004019c0 <decode+0x870> addiu $3,$2,-4
004019c8 <decode+0x878> sw $3,44($30)
../benchmarks/adpcm/adpcm.c:595
    ad_ptr1 = ad_ptr - 1;
004019d0 <decode+0x880> lw $2,48($30)
004019d8 <decode+0x888> addiu $3,$2,-4
004019e0 <decode+0x890> sw $3,52($30)
../benchmarks/adpcm/adpcm.c:596
    for(i = 0 ; i < 10 ; i++) {
004019e8 <decode+0x898> sw $0,24($30)
004019f0 <decode+0x8a0> lw $2,24($30)
004019f8 <decode+0x8a8> slti $3,$2,10
00401a00 <decode+0x8b0> bne $3,$0,00401a10 <decode+0x8c0>
00401a08 <decode+0x8b8> j 00401ab8 <decode+0x968>
../benchmarks/adpcm/adpcm.c:597
        *ac_ptr-- = *ac_ptr1--;
00401a10 <decode+0x8c0> lw $2,40($30)
00401a18 <decode+0x8c8> addiu $3,$2,-4
00401a20 <decode+0x8d0> sw $3,40($30)
00401a28 <decode+0x8d8> lw $3,44($30)
00401a30 <decode+0x8e0> addiu $4,$3,-4
00401a38 <decode+0x8e8> sw $4,44($30)
00401a40 <decode+0x8f0> lw $3,0($3)
00401a48 <decode+0x8f8> sw $3,0($2)
../benchmarks/adpcm/adpcm.c:598
        *ad_ptr-- = *ad_ptr1--;
00401a50 <decode+0x900> lw $2,48($30)
00401a58 <decode+0x908> addiu $3,$2,-4
00401a60 <decode+0x910> sw $3,48($30)
00401a68 <decode+0x918> lw $3,52($30)
00401a70 <decode+0x920> addiu $4,$3,-4
00401a78 <decode+0x928> sw $4,52($30)
00401a80 <decode+0x930> lw $3,0($3)
00401a88 <decode+0x938> sw $3,0($2)
../benchmarks/adpcm/adpcm.c:596
00401a90 <decode+0x940> lw $3,24($30)
00401a98 <decode+0x948> addiu $2,$3,1
00401aa0 <decode+0x950> addu $3,$0,$2
00401aa8 <decode+0x958> sw $3,24($30)
00401ab0 <decode+0x960> j 004019f0 <decode+0x8a0>
../benchmarks/adpcm/adpcm.c:600
    }
    *ac_ptr = xd;
00401ab8 <decode+0x968> lw $2,40($30)
00401ac0 <decode+0x970> lw $3,-32412($28)
00401ac8 <decode+0x978> sw $3,0($2)
../benchmarks/adpcm/adpcm.c:601
    *ad_ptr = xs;
00401ad0 <decode+0x980> lw $2,48($30)
00401ad8 <decode+0x988> lw $3,-32348($28)
00401ae0 <decode+0x990> sw $3,0($2)
../benchmarks/adpcm/adpcm.c:603

    return;
00401ae8 <decode+0x998> j 00401af0 <decode+0x9a0>
../benchmarks/adpcm/adpcm.c:604
}
00401af0 <decode+0x9a0> addu $29,$0,$30
00401af8 <decode+0x9a8> lw $31,60($29)
00401b00 <decode+0x9b0> lw $30,56($29)
00401b08 <decode+0x9b8> addiu $29,$29,64
00401b10 <decode+0x9c0> jr $31
reset():
../benchmarks/adpcm/adpcm.c:609

/* clear all storage locations */

void reset()
{
00401b18 <reset> addiu $29,$29,-16
00401b20 <reset+0x8> sw $30,8($29)
00401b28 <reset+0x10> addu $30,$0,$29
../benchmarks/adpcm/adpcm.c:612
    int i;

    detl = dec_detl = 32;   /* reset to min scale factor */
00401b30 <reset+0x18> addiu $2,$0,32
00401b38 <reset+0x20> sw $2,-32404($28)
00401b40 <reset+0x28> addiu $2,$0,32
00401b48 <reset+0x30> sw $2,-32564($28)
../benchmarks/adpcm/adpcm.c:613
    deth = dec_deth = 8;
00401b50 <reset+0x38> addiu $2,$0,8
00401b58 <reset+0x40> sw $2,-32484($28)
00401b60 <reset+0x48> addiu $2,$0,8
00401b68 <reset+0x50> sw $2,-32508($28)
../benchmarks/adpcm/adpcm.c:614
    nbl = al1 = al2 = plt1 = plt2 = rlt1 = rlt2 = 0;
00401b70 <reset+0x58> sw $0,-32480($28)
00401b78 <reset+0x60> sw $0,-32368($28)
00401b80 <reset+0x68> sw $0,-32408($28)
00401b88 <reset+0x70> sw $0,-32396($28)
00401b90 <reset+0x78> sw $0,-32384($28)
00401b98 <reset+0x80> sw $0,-32344($28)
00401ba0 <reset+0x88> sw $0,-32592($28)
../benchmarks/adpcm/adpcm.c:615
    nbh = ah1 = ah2 = ph1 = ph2 = rh1 = rh2 = 0;
00401ba8 <reset+0x90> sw $0,-32616($28)
00401bb0 <reset+0x98> sw $0,-32420($28)
00401bb8 <reset+0xa0> sw $0,-32476($28)
00401bc0 <reset+0xa8> sw $0,-32424($28)
00401bc8 <reset+0xb0> sw $0,-32468($28)
00401bd0 <reset+0xb8> sw $0,-32552($28)
00401bd8 <reset+0xc0> sw $0,-32372($28)
../benchmarks/adpcm/adpcm.c:616
    dec_nbl = dec_al1 = dec_al2 = dec_plt1 = dec_plt2 = dec_rlt1 = dec_rlt2 = 0;
00401be0 <reset+0xc8> sw $0,-32504($28)
00401be8 <reset+0xd0> sw $0,-32500($28)
00401bf0 <reset+0xd8> sw $0,-32620($28)
00401bf8 <reset+0xe0> sw $0,-32596($28)
00401c00 <reset+0xe8> sw $0,-32400($28)
00401c08 <reset+0xf0> sw $0,-32364($28)
00401c10 <reset+0xf8> sw $0,-32444($28)
../benchmarks/adpcm/adpcm.c:617
    dec_nbh = dec_ah1 = dec_ah2 = dec_ph1 = dec_ph2 = dec_rh1 = dec_rh2 = 0;
00401c18 <reset+0x100> sw $0,-32388($28)
00401c20 <reset+0x108> sw $0,-32380($28)
00401c28 <reset+0x110> sw $0,-32528($28)
00401c30 <reset+0x118> sw $0,-32584($28)
00401c38 <reset+0x120> sw $0,-32352($28)
00401c40 <reset+0x128> sw $0,-32524($28)
00401c48 <reset+0x130> sw $0,-32588($28)
../benchmarks/adpcm/adpcm.c:619

    for(i = 0 ; i < 6 ; i++) {
00401c50 <reset+0x138> sw $0,0($30)
00401c58 <reset+0x140> lw $2,0($30)
00401c60 <reset+0x148> slti $3,$2,6
00401c68 <reset+0x150> bne $3,$0,00401c78 <reset+0x160>
00401c70 <reset+0x158> j 00401d80 <reset+0x268>
../benchmarks/adpcm/adpcm.c:620
        delay_dltx[i] = 0;
00401c78 <reset+0x160> lw $2,0($30)
00401c80 <reset+0x168> addu $3,$0,$2
00401c88 <reset+0x170> sll $2,$3,0x2
00401c90 <reset+0x178> lui $3,4096
00401c98 <reset+0x180> addiu $3,$3,2480
00401ca0 <reset+0x188> addu $2,$2,$3
00401ca8 <reset+0x190> sw $0,0($2)
../benchmarks/adpcm/adpcm.c:621
        delay_dhx[i] = 0;
00401cb0 <reset+0x198> lw $2,0($30)
00401cb8 <reset+0x1a0> addu $3,$0,$2
00401cc0 <reset+0x1a8> sll $2,$3,0x2
00401cc8 <reset+0x1b0> lui $3,4096
00401cd0 <reset+0x1b8> addiu $3,$3,2624
00401cd8 <reset+0x1c0> addu $2,$2,$3
00401ce0 <reset+0x1c8> sw $0,0($2)
../benchmarks/adpcm/adpcm.c:622
        dec_del_dltx[i] = 0;
00401ce8 <reset+0x1d0> lw $2,0($30)
00401cf0 <reset+0x1d8> addu $3,$0,$2
00401cf8 <reset+0x1e0> sll $2,$3,0x2
00401d00 <reset+0x1e8> lui $3,4096
00401d08 <reset+0x1f0> addiu $3,$3,2512
00401d10 <reset+0x1f8> addu $2,$2,$3
00401d18 <reset+0x200> sw $0,0($2)
../benchmarks/adpcm/adpcm.c:623
        dec_del_dhx[i] = 0;
00401d20 <reset+0x208> lw $2,0($30)
00401d28 <reset+0x210> addu $3,$0,$2
00401d30 <reset+0x218> sll $2,$3,0x2
00401d38 <reset+0x220> lui $3,4096
00401d40 <reset+0x228> addiu $3,$3,2592
00401d48 <reset+0x230> addu $2,$2,$3
00401d50 <reset+0x238> sw $0,0($2)
../benchmarks/adpcm/adpcm.c:619
00401d58 <reset+0x240> lw $3,0($30)
00401d60 <reset+0x248> addiu $2,$3,1
00401d68 <reset+0x250> addu $3,$0,$2
00401d70 <reset+0x258> sw $3,0($30)
00401d78 <reset+0x260> j 00401c58 <reset+0x140>
../benchmarks/adpcm/adpcm.c:626
    }

    for(i = 0 ; i < 6 ; i++) {
00401d80 <reset+0x268> sw $0,0($30)
00401d88 <reset+0x270> lw $2,0($30)
00401d90 <reset+0x278> slti $3,$2,6
00401d98 <reset+0x280> bne $3,$0,00401da8 <reset+0x290>
00401da0 <reset+0x288> j 00401eb0 <reset+0x398>
../benchmarks/adpcm/adpcm.c:627
        delay_bpl[i] = 0;
00401da8 <reset+0x290> lw $2,0($30)
00401db0 <reset+0x298> addu $3,$0,$2
00401db8 <reset+0x2a0> sll $2,$3,0x2
00401dc0 <reset+0x2a8> lui $3,4096
00401dc8 <reset+0x2b0> addiu $3,$3,2832
00401dd0 <reset+0x2b8> addu $2,$2,$3
00401dd8 <reset+0x2c0> sw $0,0($2)
../benchmarks/adpcm/adpcm.c:628
        delay_bph[i] = 0;
00401de0 <reset+0x2c8> lw $2,0($30)
00401de8 <reset+0x2d0> addu $3,$0,$2
00401df0 <reset+0x2d8> sll $2,$3,0x2
00401df8 <reset+0x2e0> lui $3,4096
00401e00 <reset+0x2e8> addiu $3,$3,2896
00401e08 <reset+0x2f0> addu $2,$2,$3
00401e10 <reset+0x2f8> sw $0,0($2)
../benchmarks/adpcm/adpcm.c:629
        dec_del_bpl[i] = 0;
00401e18 <reset+0x300> lw $2,0($30)
00401e20 <reset+0x308> addu $3,$0,$2
00401e28 <reset+0x310> sll $2,$3,0x2
00401e30 <reset+0x318> lui $3,4096
00401e38 <reset+0x320> addiu $3,$3,2864
00401e40 <reset+0x328> addu $2,$2,$3
00401e48 <reset+0x330> sw $0,0($2)
../benchmarks/adpcm/adpcm.c:630
        dec_del_bph[i] = 0;
00401e50 <reset+0x338> lw $2,0($30)
00401e58 <reset+0x340> addu $3,$0,$2
00401e60 <reset+0x348> sll $2,$3,0x2
00401e68 <reset+0x350> lui $3,4096
00401e70 <reset+0x358> addiu $3,$3,2752
00401e78 <reset+0x360> addu $2,$2,$3
00401e80 <reset+0x368> sw $0,0($2)
../benchmarks/adpcm/adpcm.c:626
00401e88 <reset+0x370> lw $3,0($30)
00401e90 <reset+0x378> addiu $2,$3,1
00401e98 <reset+0x380> addu $3,$0,$2
00401ea0 <reset+0x388> sw $3,0($30)
00401ea8 <reset+0x390> j 00401d88 <reset+0x270>
../benchmarks/adpcm/adpcm.c:633
    }

    for(i = 0 ; i < 23 ; i++) tqmf[i] = 0;
00401eb0 <reset+0x398> sw $0,0($30)
00401eb8 <reset+0x3a0> lw $2,0($30)
00401ec0 <reset+0x3a8> slti $3,$2,23
00401ec8 <reset+0x3b0> bne $3,$0,00401ed8 <reset+0x3c0>
00401ed0 <reset+0x3b8> j 00401f38 <reset+0x420>
00401ed8 <reset+0x3c0> lw $2,0($30)
00401ee0 <reset+0x3c8> addu $3,$0,$2
00401ee8 <reset+0x3d0> sll $2,$3,0x2
00401ef0 <reset+0x3d8> lui $3,4096
00401ef8 <reset+0x3e0> addiu $3,$3,2656
00401f00 <reset+0x3e8> addu $2,$2,$3
00401f08 <reset+0x3f0> sw $0,0($2)
00401f10 <reset+0x3f8> lw $3,0($30)
00401f18 <reset+0x400> addiu $2,$3,1
00401f20 <reset+0x408> addu $3,$0,$2
00401f28 <reset+0x410> sw $3,0($30)
00401f30 <reset+0x418> j 00401eb8 <reset+0x3a0>
../benchmarks/adpcm/adpcm.c:635

    for(i = 0 ; i < 11 ; i++) {
00401f38 <reset+0x420> sw $0,0($30)
00401f40 <reset+0x428> lw $2,0($30)
00401f48 <reset+0x430> slti $3,$2,11
00401f50 <reset+0x438> bne $3,$0,00401f60 <reset+0x448>
00401f58 <reset+0x440> j 00401ff8 <reset+0x4e0>
../benchmarks/adpcm/adpcm.c:636
        accumc[i] = 0;
00401f60 <reset+0x448> lw $2,0($30)
00401f68 <reset+0x450> addu $3,$0,$2
00401f70 <reset+0x458> sll $2,$3,0x2
00401f78 <reset+0x460> lui $3,4096
00401f80 <reset+0x468> addiu $3,$3,2784
00401f88 <reset+0x470> addu $2,$2,$3
00401f90 <reset+0x478> sw $0,0($2)
../benchmarks/adpcm/adpcm.c:637
        accumd[i] = 0;
00401f98 <reset+0x480> lw $2,0($30)
00401fa0 <reset+0x488> addu $3,$0,$2
00401fa8 <reset+0x490> sll $2,$3,0x2
00401fb0 <reset+0x498> lui $3,4096
00401fb8 <reset+0x4a0> addiu $3,$3,2544
00401fc0 <reset+0x4a8> addu $2,$2,$3
00401fc8 <reset+0x4b0> sw $0,0($2)
../benchmarks/adpcm/adpcm.c:635
00401fd0 <reset+0x4b8> lw $3,0($30)
00401fd8 <reset+0x4c0> addiu $2,$3,1
00401fe0 <reset+0x4c8> addu $3,$0,$2
00401fe8 <reset+0x4d0> sw $3,0($30)
00401ff0 <reset+0x4d8> j 00401f40 <reset+0x428>
../benchmarks/adpcm/adpcm.c:639
    }
    return;
00401ff8 <reset+0x4e0> j 00402000 <reset+0x4e8>
../benchmarks/adpcm/adpcm.c:640
}
00402000 <reset+0x4e8> addu $29,$0,$30
00402008 <reset+0x4f0> lw $30,8($29)
00402010 <reset+0x4f8> addiu $29,$29,16
00402018 <reset+0x500> jr $31
filtez():
../benchmarks/adpcm/adpcm.c:646

/* filtez - compute predictor output signal (zero section) */
/* input: bpl1-6 and dlt1-6, output: szl */

int filtez(int *bpl,int *dlt)
{
00402020 <filtez> addiu $29,$29,-16
00402028 <filtez+0x8> sw $30,8($29)
00402030 <filtez+0x10> addu $30,$0,$29
00402038 <filtez+0x18> sw $4,16($30)
00402040 <filtez+0x20> sw $5,20($30)
../benchmarks/adpcm/adpcm.c:649
    int i;
    long int zl;
    zl = (long)(*bpl++) * (*dlt++);
00402048 <filtez+0x28> lw $2,16($30)
00402050 <filtez+0x30> addiu $3,$2,4
00402058 <filtez+0x38> sw $3,16($30)
00402060 <filtez+0x40> lw $3,20($30)
00402068 <filtez+0x48> addiu $4,$3,4
00402070 <filtez+0x50> sw $4,20($30)
00402078 <filtez+0x58> lw $2,0($2)
00402080 <filtez+0x60> lw $3,0($3)
00402088 <filtez+0x68> mult $2,$3
00402090 <filtez+0x70> mflo $2
00402098 <filtez+0x78> sw $2,4($30)
../benchmarks/adpcm/adpcm.c:651
    /* MAX: 6 */
    for(i = 1 ; i < 6 ; i++)
004020a0 <filtez+0x80> addiu $2,$0,1
004020a8 <filtez+0x88> sw $2,0($30)
004020b0 <filtez+0x90> lw $2,0($30)
004020b8 <filtez+0x98> slti $3,$2,6
004020c0 <filtez+0xa0> bne $3,$0,004020d0 <filtez+0xb0>
004020c8 <filtez+0xa8> j 00402160 <filtez+0x140>
../benchmarks/adpcm/adpcm.c:652
        zl += (long)(*bpl++) * (*dlt++);
004020d0 <filtez+0xb0> lw $2,16($30)
004020d8 <filtez+0xb8> addiu $3,$2,4
004020e0 <filtez+0xc0> sw $3,16($30)
004020e8 <filtez+0xc8> lw $3,20($30)
004020f0 <filtez+0xd0> addiu $4,$3,4
004020f8 <filtez+0xd8> sw $4,20($30)
00402100 <filtez+0xe0> lw $2,0($2)
00402108 <filtez+0xe8> lw $3,0($3)
00402110 <filtez+0xf0> mult $2,$3
00402118 <filtez+0xf8> mflo $2
00402120 <filtez+0x100> lw $3,4($30)
00402128 <filtez+0x108> addu $2,$3,$2
00402130 <filtez+0x110> sw $2,4($30)
../benchmarks/adpcm/adpcm.c:651
00402138 <filtez+0x118> lw $3,0($30)
00402140 <filtez+0x120> addiu $2,$3,1
00402148 <filtez+0x128> addu $3,$0,$2
00402150 <filtez+0x130> sw $3,0($30)
00402158 <filtez+0x138> j 004020b0 <filtez+0x90>
../benchmarks/adpcm/adpcm.c:654

    return((int)(zl >> 14));   /* x2 here */
00402160 <filtez+0x140> lw $2,4($30)
00402168 <filtez+0x148> sra $3,$2,0xe
00402170 <filtez+0x150> addu $2,$0,$3
00402178 <filtez+0x158> j 00402180 <filtez+0x160>
../benchmarks/adpcm/adpcm.c:655
}
00402180 <filtez+0x160> addu $29,$0,$30
00402188 <filtez+0x168> lw $30,8($29)
00402190 <filtez+0x170> addiu $29,$29,16
00402198 <filtez+0x178> jr $31
filtep():
../benchmarks/adpcm/adpcm.c:661

/* filtep - compute predictor output signal (pole section) */
/* input rlt1-2 and al1-2, output spl */

int filtep(int rlt1,int al1,int rlt2,int al2)
{
004021a0 <filtep> addiu $29,$29,-16
004021a8 <filtep+0x8> sw $30,8($29)
004021b0 <filtep+0x10> addu $30,$0,$29
004021b8 <filtep+0x18> sw $4,16($30)
004021c0 <filtep+0x20> sw $5,20($30)
004021c8 <filtep+0x28> sw $6,24($30)
004021d0 <filtep+0x30> sw $7,28($30)
../benchmarks/adpcm/adpcm.c:663
    long int pl,pl2;
    pl = 2*rlt1;
004021d8 <filtep+0x38> lw $2,16($30)
004021e0 <filtep+0x40> addu $3,$0,$2
004021e8 <filtep+0x48> sll $2,$3,0x1
004021f0 <filtep+0x50> sw $2,0($30)
../benchmarks/adpcm/adpcm.c:664
    pl = (long)al1*pl;
004021f8 <filtep+0x58> lw $2,0($30)
00402200 <filtep+0x60> lw $3,20($30)
00402208 <filtep+0x68> mult $2,$3
00402210 <filtep+0x70> mflo $2
00402218 <filtep+0x78> sw $2,0($30)
../benchmarks/adpcm/adpcm.c:665
    pl2 = 2*rlt2;
00402220 <filtep+0x80> lw $2,24($30)
00402228 <filtep+0x88> addu $3,$0,$2
00402230 <filtep+0x90> sll $2,$3,0x1
00402238 <filtep+0x98> sw $2,4($30)
../benchmarks/adpcm/adpcm.c:666
    pl += (long)al2*pl2;
00402240 <filtep+0xa0> lw $2,28($30)
00402248 <filtep+0xa8> lw $3,4($30)
00402250 <filtep+0xb0> mult $2,$3
00402258 <filtep+0xb8> mflo $2
00402260 <filtep+0xc0> lw $3,0($30)
00402268 <filtep+0xc8> addu $2,$3,$2
00402270 <filtep+0xd0> sw $2,0($30)
../benchmarks/adpcm/adpcm.c:667
    return((int)(pl >> 15));
00402278 <filtep+0xd8> lw $2,0($30)
00402280 <filtep+0xe0> sra $3,$2,0xf
00402288 <filtep+0xe8> addu $2,$0,$3
00402290 <filtep+0xf0> j 00402298 <filtep+0xf8>
../benchmarks/adpcm/adpcm.c:668
}
00402298 <filtep+0xf8> addu $29,$0,$30
004022a0 <filtep+0x100> lw $30,8($29)
004022a8 <filtep+0x108> addiu $29,$29,16
004022b0 <filtep+0x110> jr $31
quantl():
../benchmarks/adpcm/adpcm.c:672

/* quantl - quantize the difference signal in the lower sub-band */
int quantl(int el,int detl)
{
004022b8 <quantl> addiu $29,$29,-40
004022c0 <quantl+0x8> sw $31,36($29)
004022c8 <quantl+0x10> sw $30,32($29)
004022d0 <quantl+0x18> addu $30,$0,$29
004022d8 <quantl+0x20> sw $4,40($30)
004022e0 <quantl+0x28> sw $5,44($30)
../benchmarks/adpcm/adpcm.c:677
    int ril,mil;
    long int wd,decis;

/* abs of difference signal */
    wd = my_abs(el);
004022e8 <quantl+0x30> lw $4,40($30)
004022f0 <quantl+0x38> jal 004001f0 <my_abs>
004022f8 <quantl+0x40> sw $2,24($30)
../benchmarks/adpcm/adpcm.c:680
/* determine mil based on decision levels and detl gain */
    /* MAX: 30 */
    for(mil = 0 ; mil < 30 ; mil++) {
00402300 <quantl+0x48> sw $0,20($30)
00402308 <quantl+0x50> lw $2,20($30)
00402310 <quantl+0x58> slti $3,$2,30
00402318 <quantl+0x60> bne $3,$0,00402328 <quantl+0x70>
00402320 <quantl+0x68> j 004023d8 <quantl+0x120>
../benchmarks/adpcm/adpcm.c:681
        decis = (decis_levl[mil]*(long)detl) >> 15L;
00402328 <quantl+0x70> lw $2,20($30)
00402330 <quantl+0x78> addu $3,$0,$2
00402338 <quantl+0x80> sll $2,$3,0x2
00402340 <quantl+0x88> lui $3,4096
00402348 <quantl+0x90> addiu $3,$3,864
00402350 <quantl+0x98> addu $2,$2,$3
00402358 <quantl+0xa0> lw $3,0($2)
00402360 <quantl+0xa8> lw $4,44($30)
00402368 <quantl+0xb0> mult $3,$4
00402370 <quantl+0xb8> mflo $2
00402378 <quantl+0xc0> sra $3,$2,0xf
00402380 <quantl+0xc8> sw $3,28($30)
../benchmarks/adpcm/adpcm.c:682
        if(wd <= decis) break;
00402388 <quantl+0xd0> lw $2,24($30)
00402390 <quantl+0xd8> lw $3,28($30)
00402398 <quantl+0xe0> slt $2,$3,$2
004023a0 <quantl+0xe8> bne $2,$0,004023b0 <quantl+0xf8>
004023a8 <quantl+0xf0> j 004023d8 <quantl+0x120>
../benchmarks/adpcm/adpcm.c:680
004023b0 <quantl+0xf8> lw $3,20($30)
004023b8 <quantl+0x100> addiu $2,$3,1
004023c0 <quantl+0x108> addu $3,$0,$2
004023c8 <quantl+0x110> sw $3,20($30)
004023d0 <quantl+0x118> j 00402308 <quantl+0x50>
../benchmarks/adpcm/adpcm.c:685
    }
/* if mil=30 then wd is less than all decision levels */
    if(el >= 0) ril = quant26bt_pos[mil];
004023d8 <quantl+0x120> lw $2,40($30)
004023e0 <quantl+0x128> bltz $2,00402430 <quantl+0x178>
004023e8 <quantl+0x130> lw $2,20($30)
004023f0 <quantl+0x138> addu $3,$0,$2
004023f8 <quantl+0x140> sll $2,$3,0x2
00402400 <quantl+0x148> lui $3,4096
00402408 <quantl+0x150> addiu $3,$3,984
00402410 <quantl+0x158> addu $2,$2,$3
00402418 <quantl+0x160> lw $3,0($2)
00402420 <quantl+0x168> sw $3,16($30)
00402428 <quantl+0x170> j 00402470 <quantl+0x1b8>
../benchmarks/adpcm/adpcm.c:686
    else ril = quant26bt_neg[mil];
00402430 <quantl+0x178> lw $2,20($30)
00402438 <quantl+0x180> addu $3,$0,$2
00402440 <quantl+0x188> sll $2,$3,0x2
00402448 <quantl+0x190> lui $3,4096
00402450 <quantl+0x198> addiu $3,$3,1108
00402458 <quantl+0x1a0> addu $2,$2,$3
00402460 <quantl+0x1a8> lw $3,0($2)
00402468 <quantl+0x1b0> sw $3,16($30)
../benchmarks/adpcm/adpcm.c:687
    return(ril);
00402470 <quantl+0x1b8> lw $2,16($30)
00402478 <quantl+0x1c0> j 00402480 <quantl+0x1c8>
../benchmarks/adpcm/adpcm.c:688
}
00402480 <quantl+0x1c8> addu $29,$0,$30
00402488 <quantl+0x1d0> lw $31,36($29)
00402490 <quantl+0x1d8> lw $30,32($29)
00402498 <quantl+0x1e0> addiu $29,$29,40
004024a0 <quantl+0x1e8> jr $31
logscl():
../benchmarks/adpcm/adpcm.c:704

/* invqxl is either invqbl or invqal depending on parameters passed */
/* returns dlt, code table is pre-multiplied by 8 */

/*    int invqxl(int il,int detl,int *code_table,int mode) */
/*    { */
/*        long int dlt; */
/*       dlt = (long)detl*code_table[il >> (mode-1)]; */
/*        return((int)(dlt >> 15)); */
/*    } */

/* logscl - update log quantizer scale factor in lower sub-band */
/* note that nbl is passed and returned */

int logscl(int il,int nbl)
{
004024a8 <logscl> addiu $29,$29,-16
004024b0 <logscl+0x8> sw $30,8($29)
004024b8 <logscl+0x10> addu $30,$0,$29
004024c0 <logscl+0x18> sw $4,16($30)
004024c8 <logscl+0x20> sw $5,20($30)
../benchmarks/adpcm/adpcm.c:706
    long int wd;
    wd = ((long)nbl * 127L) >> 7L;   /* leak factor 127/128 */
004024d0 <logscl+0x28> lw $2,20($30)
004024d8 <logscl+0x30> addu $4,$0,$2
004024e0 <logscl+0x38> sll $3,$4,0x7
004024e8 <logscl+0x40> subu $3,$3,$2
004024f0 <logscl+0x48> sra $2,$3,0x7
004024f8 <logscl+0x50> sw $2,0($30)
../benchmarks/adpcm/adpcm.c:707
    nbl = (int)wd + wl_code_table[il >> 2];
00402500 <logscl+0x58> lw $3,16($30)
00402508 <logscl+0x60> sra $2,$3,0x2
00402510 <logscl+0x68> addu $3,$0,$2
00402518 <logscl+0x70> sll $2,$3,0x2
00402520 <logscl+0x78> lui $3,4096
00402528 <logscl+0x80> addiu $3,$3,640
00402530 <logscl+0x88> addu $2,$2,$3
00402538 <logscl+0x90> lw $3,0($30)
00402540 <logscl+0x98> lw $2,0($2)
00402548 <logscl+0xa0> addu $3,$3,$2
00402550 <logscl+0xa8> sw $3,20($30)
../benchmarks/adpcm/adpcm.c:708
    if(nbl < 0) nbl = 0;
00402558 <logscl+0xb0> lw $2,20($30)
00402560 <logscl+0xb8> bgez $2,00402570 <logscl+0xc8>
00402568 <logscl+0xc0> sw $0,20($30)
../benchmarks/adpcm/adpcm.c:709
    if(nbl > 18432) nbl = 18432;
00402570 <logscl+0xc8> lw $2,20($30)
00402578 <logscl+0xd0> slti $3,$2,18433
00402580 <logscl+0xd8> bne $3,$0,00402598 <logscl+0xf0>
00402588 <logscl+0xe0> addiu $2,$0,18432
00402590 <logscl+0xe8> sw $2,20($30)
../benchmarks/adpcm/adpcm.c:710
    return(nbl);
00402598 <logscl+0xf0> lw $2,20($30)
004025a0 <logscl+0xf8> j 004025a8 <logscl+0x100>
../benchmarks/adpcm/adpcm.c:711
}
004025a8 <logscl+0x100> addu $29,$0,$30
004025b0 <logscl+0x108> lw $30,8($29)
004025b8 <logscl+0x110> addiu $29,$29,16
004025c0 <logscl+0x118> jr $31
scalel():
../benchmarks/adpcm/adpcm.c:716

/* scalel: compute quantizer scale factor in lower or upper sub-band*/

int scalel(int nbl,int shift_constant)
{
004025c8 <scalel> addiu $29,$29,-24
004025d0 <scalel+0x8> sw $30,16($29)
004025d8 <scalel+0x10> addu $30,$0,$29
004025e0 <scalel+0x18> sw $4,24($30)
004025e8 <scalel+0x20> sw $5,28($30)
../benchmarks/adpcm/adpcm.c:718
    int wd1,wd2,wd3;
    wd1 = (nbl >> 6) & 31;
004025f0 <scalel+0x28> lw $3,24($30)
004025f8 <scalel+0x30> sra $2,$3,0x6
00402600 <scalel+0x38> andi $3,$2,31
00402608 <scalel+0x40> sw $3,0($30)
../benchmarks/adpcm/adpcm.c:719
    wd2 = nbl >> 11;
00402610 <scalel+0x48> lw $2,24($30)
00402618 <scalel+0x50> sra $3,$2,0xb
00402620 <scalel+0x58> sw $3,4($30)
../benchmarks/adpcm/adpcm.c:720
    wd3 = ilb_table[wd1] >> (shift_constant + 1 - wd2);
00402628 <scalel+0x60> lw $2,0($30)
00402630 <scalel+0x68> addu $3,$0,$2
00402638 <scalel+0x70> sll $2,$3,0x2
00402640 <scalel+0x78> lui $3,4096
00402648 <scalel+0x80> addiu $3,$3,736
00402650 <scalel+0x88> addu $2,$2,$3
00402658 <scalel+0x90> lw $4,4($30)
00402660 <scalel+0x98> addiu $3,$4,-1
00402668 <scalel+0xa0> lw $4,28($30)
00402670 <scalel+0xa8> subu $3,$4,$3
00402678 <scalel+0xb0> lw $2,0($2)
00402680 <scalel+0xb8> srav $3,$2,$3
00402688 <scalel+0xc0> sw $3,8($30)
../benchmarks/adpcm/adpcm.c:721
    return(wd3 << 3);
00402690 <scalel+0xc8> lw $2,8($30)
00402698 <scalel+0xd0> sll $3,$2,0x3
004026a0 <scalel+0xd8> addu $2,$0,$3
004026a8 <scalel+0xe0> j 004026b0 <scalel+0xe8>
../benchmarks/adpcm/adpcm.c:722
}
004026b0 <scalel+0xe8> addu $29,$0,$30
004026b8 <scalel+0xf0> lw $30,16($29)
004026c0 <scalel+0xf8> addiu $29,$29,24
004026c8 <scalel+0x100> jr $31
upzero():
../benchmarks/adpcm/adpcm.c:728

/* upzero - inputs: dlt, dlti[0-5], bli[0-5], outputs: updated bli[0-5] */
/* also implements delay of bli and update of dlti from dlt */

void upzero(int dlt,int *dlti,int *bli)
{
004026d0 <upzero> addiu $29,$29,-24
004026d8 <upzero+0x8> sw $30,16($29)
004026e0 <upzero+0x10> addu $30,$0,$29
004026e8 <upzero+0x18> sw $4,24($30)
004026f0 <upzero+0x20> sw $5,28($30)
004026f8 <upzero+0x28> sw $6,32($30)
../benchmarks/adpcm/adpcm.c:731
    int i,wd2,wd3;
/*if dlt is zero, then no sum into bli */
    if(dlt == 0) {
00402700 <upzero+0x30> lw $2,24($30)
00402708 <upzero+0x38> bne $2,$0,004027e8 <upzero+0x118>
../benchmarks/adpcm/adpcm.c:732
      for(i = 0 ; i < 6 ; i++) {
00402710 <upzero+0x40> sw $0,0($30)
00402718 <upzero+0x48> lw $2,0($30)
00402720 <upzero+0x50> slti $3,$2,6
00402728 <upzero+0x58> bne $3,$0,00402738 <upzero+0x68>
00402730 <upzero+0x60> j 004027e0 <upzero+0x110>
../benchmarks/adpcm/adpcm.c:733
        bli[i] = (int)((255L*bli[i]) >> 8L); /* leak factor of 255/256 */
00402738 <upzero+0x68> lw $2,0($30)
00402740 <upzero+0x70> addu $3,$0,$2
00402748 <upzero+0x78> sll $2,$3,0x2
00402750 <upzero+0x80> lw $3,32($30)
00402758 <upzero+0x88> addu $2,$2,$3
00402760 <upzero+0x90> lw $3,0($30)
00402768 <upzero+0x98> addu $4,$0,$3
00402770 <upzero+0xa0> sll $3,$4,0x2
00402778 <upzero+0xa8> lw $5,32($30)
00402780 <upzero+0xb0> addu $4,$3,$5
00402788 <upzero+0xb8> lw $3,0($4)
00402790 <upzero+0xc0> addu $5,$0,$3
00402798 <upzero+0xc8> sll $4,$5,0x8
004027a0 <upzero+0xd0> subu $4,$4,$3
004027a8 <upzero+0xd8> sra $3,$4,0x8
004027b0 <upzero+0xe0> sw $3,0($2)
../benchmarks/adpcm/adpcm.c:732
004027b8 <upzero+0xe8> lw $3,0($30)
004027c0 <upzero+0xf0> addiu $2,$3,1
004027c8 <upzero+0xf8> addu $3,$0,$2
004027d0 <upzero+0x100> sw $3,0($30)
004027d8 <upzero+0x108> j 00402718 <upzero+0x48>
../benchmarks/adpcm/adpcm.c:735
      }
    }
004027e0 <upzero+0x110> j 00402950 <upzero+0x280>
../benchmarks/adpcm/adpcm.c:737
    else {
      for(i = 0 ; i < 6 ; i++) {
004027e8 <upzero+0x118> sw $0,0($30)
004027f0 <upzero+0x120> lw $2,0($30)
004027f8 <upzero+0x128> slti $3,$2,6
00402800 <upzero+0x130> bne $3,$0,00402810 <upzero+0x140>
00402808 <upzero+0x138> j 00402950 <upzero+0x280>
../benchmarks/adpcm/adpcm.c:738
        if((long)dlt*dlti[i] >= 0) wd2 = 128; else wd2 = -128;
00402810 <upzero+0x140> lw $2,0($30)
00402818 <upzero+0x148> addu $3,$0,$2
00402820 <upzero+0x150> sll $2,$3,0x2
00402828 <upzero+0x158> lw $3,28($30)
00402830 <upzero+0x160> addu $2,$2,$3
00402838 <upzero+0x168> lw $3,24($30)
00402840 <upzero+0x170> lw $4,0($2)
00402848 <upzero+0x178> mult $3,$4
00402850 <upzero+0x180> mflo $2
00402858 <upzero+0x188> bltz $2,00402878 <upzero+0x1a8>
00402860 <upzero+0x190> addiu $2,$0,128
00402868 <upzero+0x198> sw $2,4($30)
00402870 <upzero+0x1a0> j 00402888 <upzero+0x1b8>
00402878 <upzero+0x1a8> addiu $2,$0,-128
00402880 <upzero+0x1b0> sw $2,4($30)
../benchmarks/adpcm/adpcm.c:739
        wd3 = (int)((255L*bli[i]) >> 8L);    /* leak factor of 255/256 */
00402888 <upzero+0x1b8> lw $2,0($30)
00402890 <upzero+0x1c0> addu $3,$0,$2
00402898 <upzero+0x1c8> sll $2,$3,0x2
004028a0 <upzero+0x1d0> lw $4,32($30)
004028a8 <upzero+0x1d8> addu $3,$2,$4
004028b0 <upzero+0x1e0> lw $2,0($3)
004028b8 <upzero+0x1e8> addu $4,$0,$2
004028c0 <upzero+0x1f0> sll $3,$4,0x8
004028c8 <upzero+0x1f8> subu $3,$3,$2
004028d0 <upzero+0x200> sra $2,$3,0x8
004028d8 <upzero+0x208> sw $2,8($30)
../benchmarks/adpcm/adpcm.c:740
        bli[i] = wd2 + wd3;
004028e0 <upzero+0x210> lw $2,0($30)
004028e8 <upzero+0x218> addu $3,$0,$2
004028f0 <upzero+0x220> sll $2,$3,0x2
004028f8 <upzero+0x228> lw $3,32($30)
00402900 <upzero+0x230> addu $2,$2,$3
00402908 <upzero+0x238> lw $3,4($30)
00402910 <upzero+0x240> lw $4,8($30)
00402918 <upzero+0x248> addu $3,$3,$4
00402920 <upzero+0x250> sw $3,0($2)
../benchmarks/adpcm/adpcm.c:737
00402928 <upzero+0x258> lw $3,0($30)
00402930 <upzero+0x260> addiu $2,$3,1
00402938 <upzero+0x268> addu $3,$0,$2
00402940 <upzero+0x270> sw $3,0($30)
00402948 <upzero+0x278> j 004027f0 <upzero+0x120>
../benchmarks/adpcm/adpcm.c:744
      }
    }
/* implement delay line for dlt */
    dlti[5] = dlti[4];
00402950 <upzero+0x280> lw $3,28($30)
00402958 <upzero+0x288> addiu $2,$3,20
00402960 <upzero+0x290> lw $4,28($30)
00402968 <upzero+0x298> addiu $3,$4,16
00402970 <upzero+0x2a0> lw $4,0($3)
00402978 <upzero+0x2a8> sw $4,0($2)
../benchmarks/adpcm/adpcm.c:745
    dlti[4] = dlti[3];
00402980 <upzero+0x2b0> lw $3,28($30)
00402988 <upzero+0x2b8> addiu $2,$3,16
00402990 <upzero+0x2c0> lw $4,28($30)
00402998 <upzero+0x2c8> addiu $3,$4,12
004029a0 <upzero+0x2d0> lw $4,0($3)
004029a8 <upzero+0x2d8> sw $4,0($2)
../benchmarks/adpcm/adpcm.c:746
    dlti[3] = dlti[2];
004029b0 <upzero+0x2e0> lw $3,28($30)
004029b8 <upzero+0x2e8> addiu $2,$3,12
004029c0 <upzero+0x2f0> lw $4,28($30)
004029c8 <upzero+0x2f8> addiu $3,$4,8
004029d0 <upzero+0x300> lw $4,0($3)
004029d8 <upzero+0x308> sw $4,0($2)
../benchmarks/adpcm/adpcm.c:747
    dlti[1] = dlti[0];
004029e0 <upzero+0x310> lw $3,28($30)
004029e8 <upzero+0x318> addiu $2,$3,4
004029f0 <upzero+0x320> lw $3,28($30)
004029f8 <upzero+0x328> lw $4,0($3)
00402a00 <upzero+0x330> sw $4,0($2)
../benchmarks/adpcm/adpcm.c:748
    dlti[0] = dlt;
00402a08 <upzero+0x338> lw $2,28($30)
00402a10 <upzero+0x340> lw $3,24($30)
00402a18 <upzero+0x348> sw $3,0($2)
../benchmarks/adpcm/adpcm.c:749
    return;
00402a20 <upzero+0x350> j 00402a28 <upzero+0x358>
../benchmarks/adpcm/adpcm.c:750
}
00402a28 <upzero+0x358> addu $29,$0,$30
00402a30 <upzero+0x360> lw $30,16($29)
00402a38 <upzero+0x368> addiu $29,$29,24
00402a40 <upzero+0x370> jr $31
uppol2():
../benchmarks/adpcm/adpcm.c:756

/* uppol2 - update second predictor coefficient (pole section) */
/* inputs: al1, al2, plt, plt1, plt2. outputs: apl2 */

int uppol2(int al1,int al2,int plt,int plt1,int plt2)
{
00402a48 <uppol2> addiu $29,$29,-24
00402a50 <uppol2+0x8> sw $30,16($29)
00402a58 <uppol2+0x10> addu $30,$0,$29
00402a60 <uppol2+0x18> sw $4,24($30)
00402a68 <uppol2+0x20> sw $5,28($30)
00402a70 <uppol2+0x28> sw $6,32($30)
00402a78 <uppol2+0x30> sw $7,36($30)
../benchmarks/adpcm/adpcm.c:759
    long int wd2,wd4;
    int apl2;
    wd2 = 4L*(long)al1;
00402a80 <uppol2+0x38> lw $2,24($30)
00402a88 <uppol2+0x40> addu $3,$0,$2
00402a90 <uppol2+0x48> sll $2,$3,0x2
00402a98 <uppol2+0x50> sw $2,0($30)
../benchmarks/adpcm/adpcm.c:760
    if((long)plt*plt1 >= 0L) wd2 = -wd2;    /* check same sign */
00402aa0 <uppol2+0x58> lw $2,32($30)
00402aa8 <uppol2+0x60> lw $3,36($30)
00402ab0 <uppol2+0x68> mult $2,$3
00402ab8 <uppol2+0x70> mflo $2
00402ac0 <uppol2+0x78> bltz $2,00402ae0 <uppol2+0x98>
00402ac8 <uppol2+0x80> lw $2,0($30)
00402ad0 <uppol2+0x88> subu $3,$0,$2
00402ad8 <uppol2+0x90> sw $3,0($30)
../benchmarks/adpcm/adpcm.c:761
    wd2 = wd2 >> 7;                  /* gain of 1/128 */
00402ae0 <uppol2+0x98> lw $2,0($30)
00402ae8 <uppol2+0xa0> sra $3,$2,0x7
00402af0 <uppol2+0xa8> sw $3,0($30)
../benchmarks/adpcm/adpcm.c:762
    if((long)plt*plt2 >= 0L) {
00402af8 <uppol2+0xb0> lw $2,32($30)
00402b00 <uppol2+0xb8> lw $3,40($30)
00402b08 <uppol2+0xc0> mult $2,$3
00402b10 <uppol2+0xc8> mflo $2
00402b18 <uppol2+0xd0> bltz $2,00402b40 <uppol2+0xf8>
../benchmarks/adpcm/adpcm.c:763
        wd4 = wd2 + 128;             /* same sign case */
00402b20 <uppol2+0xd8> lw $2,0($30)
00402b28 <uppol2+0xe0> addiu $3,$2,128
00402b30 <uppol2+0xe8> sw $3,4($30)
../benchmarks/adpcm/adpcm.c:764
    }
00402b38 <uppol2+0xf0> j 00402b58 <uppol2+0x110>
../benchmarks/adpcm/adpcm.c:766
    else {
        wd4 = wd2 - 128;
00402b40 <uppol2+0xf8> lw $2,0($30)
00402b48 <uppol2+0x100> addiu $3,$2,-128
00402b50 <uppol2+0x108> sw $3,4($30)
../benchmarks/adpcm/adpcm.c:768
    }
    apl2 = wd4 + (127L*(long)al2 >> 7L);  /* leak factor of 127/128 */
00402b58 <uppol2+0x110> lw $2,28($30)
00402b60 <uppol2+0x118> addu $4,$0,$2
00402b68 <uppol2+0x120> sll $3,$4,0x7
00402b70 <uppol2+0x128> subu $3,$3,$2
00402b78 <uppol2+0x130> sra $2,$3,0x7
00402b80 <uppol2+0x138> lw $3,4($30)
00402b88 <uppol2+0x140> addu $2,$3,$2
00402b90 <uppol2+0x148> sw $2,8($30)
../benchmarks/adpcm/adpcm.c:771

/* apl2 is limited to +-.75 */
    if(apl2 > 12288) apl2 = 12288;
00402b98 <uppol2+0x150> lw $2,8($30)
00402ba0 <uppol2+0x158> slti $3,$2,12289
00402ba8 <uppol2+0x160> bne $3,$0,00402bc0 <uppol2+0x178>
00402bb0 <uppol2+0x168> addiu $2,$0,12288
00402bb8 <uppol2+0x170> sw $2,8($30)
../benchmarks/adpcm/adpcm.c:772
    if(apl2 < -12288) apl2 = -12288;
00402bc0 <uppol2+0x178> lw $2,8($30)
00402bc8 <uppol2+0x180> slti $3,$2,-12288
00402bd0 <uppol2+0x188> beq $3,$0,00402be8 <uppol2+0x1a0>
00402bd8 <uppol2+0x190> addiu $2,$0,-12288
00402be0 <uppol2+0x198> sw $2,8($30)
../benchmarks/adpcm/adpcm.c:773
    return(apl2);
00402be8 <uppol2+0x1a0> lw $2,8($30)
00402bf0 <uppol2+0x1a8> j 00402bf8 <uppol2+0x1b0>
../benchmarks/adpcm/adpcm.c:774
}
00402bf8 <uppol2+0x1b0> addu $29,$0,$30
00402c00 <uppol2+0x1b8> lw $30,16($29)
00402c08 <uppol2+0x1c0> addiu $29,$29,24
00402c10 <uppol2+0x1c8> jr $31
uppol1():
../benchmarks/adpcm/adpcm.c:780

/* uppol1 - update first predictor coefficient (pole section) */
/* inputs: al1, apl2, plt, plt1. outputs: apl1 */

int uppol1(int al1,int apl2,int plt,int plt1)
{
00402c18 <uppol1> addiu $29,$29,-24
00402c20 <uppol1+0x8> sw $30,16($29)
00402c28 <uppol1+0x10> addu $30,$0,$29
00402c30 <uppol1+0x18> sw $4,24($30)
00402c38 <uppol1+0x20> sw $5,28($30)
00402c40 <uppol1+0x28> sw $6,32($30)
00402c48 <uppol1+0x30> sw $7,36($30)
../benchmarks/adpcm/adpcm.c:783
    long int wd2;
    int wd3,apl1;
    wd2 = ((long)al1*255L) >> 8L;   /* leak factor of 255/256 */
00402c50 <uppol1+0x38> lw $2,24($30)
00402c58 <uppol1+0x40> addu $4,$0,$2
00402c60 <uppol1+0x48> sll $3,$4,0x8
00402c68 <uppol1+0x50> subu $3,$3,$2
00402c70 <uppol1+0x58> sra $2,$3,0x8
00402c78 <uppol1+0x60> sw $2,0($30)
../benchmarks/adpcm/adpcm.c:784
    if((long)plt*plt1 >= 0L) {
00402c80 <uppol1+0x68> lw $2,32($30)
00402c88 <uppol1+0x70> lw $3,36($30)
00402c90 <uppol1+0x78> mult $2,$3
00402c98 <uppol1+0x80> mflo $2
00402ca0 <uppol1+0x88> bltz $2,00402cc8 <uppol1+0xb0>
../benchmarks/adpcm/adpcm.c:785
        apl1 = (int)wd2 + 192;      /* same sign case */
00402ca8 <uppol1+0x90> lw $2,0($30)
00402cb0 <uppol1+0x98> addiu $3,$2,192
00402cb8 <uppol1+0xa0> sw $3,8($30)
../benchmarks/adpcm/adpcm.c:786
    }
00402cc0 <uppol1+0xa8> j 00402ce0 <uppol1+0xc8>
../benchmarks/adpcm/adpcm.c:788
    else {
        apl1 = (int)wd2 - 192;
00402cc8 <uppol1+0xb0> lw $2,0($30)
00402cd0 <uppol1+0xb8> addiu $3,$2,-192
00402cd8 <uppol1+0xc0> sw $3,8($30)
../benchmarks/adpcm/adpcm.c:791
    }
/* note: wd3= .9375-.75 is always positive */
    wd3 = 15360 - apl2;             /* limit value */
00402ce0 <uppol1+0xc8> addiu $2,$0,15360
00402ce8 <uppol1+0xd0> lw $3,28($30)
00402cf0 <uppol1+0xd8> subu $2,$2,$3
00402cf8 <uppol1+0xe0> sw $2,4($30)
../benchmarks/adpcm/adpcm.c:792
    if(apl1 > wd3) apl1 = wd3;
00402d00 <uppol1+0xe8> lw $2,8($30)
00402d08 <uppol1+0xf0> lw $3,4($30)
00402d10 <uppol1+0xf8> slt $2,$3,$2
00402d18 <uppol1+0x100> beq $2,$0,00402d30 <uppol1+0x118>
00402d20 <uppol1+0x108> lw $2,4($30)
00402d28 <uppol1+0x110> sw $2,8($30)
../benchmarks/adpcm/adpcm.c:793
    if(apl1 < -wd3) apl1 = -wd3;
00402d30 <uppol1+0x118> lw $3,4($30)
00402d38 <uppol1+0x120> subu $2,$0,$3
00402d40 <uppol1+0x128> lw $3,8($30)
00402d48 <uppol1+0x130> slt $2,$3,$2
00402d50 <uppol1+0x138> beq $2,$0,00402d70 <uppol1+0x158>
00402d58 <uppol1+0x140> lw $2,4($30)
00402d60 <uppol1+0x148> subu $3,$0,$2
00402d68 <uppol1+0x150> sw $3,8($30)
../benchmarks/adpcm/adpcm.c:794
    return(apl1);
00402d70 <uppol1+0x158> lw $2,8($30)
00402d78 <uppol1+0x160> j 00402d80 <uppol1+0x168>
../benchmarks/adpcm/adpcm.c:795
}
00402d80 <uppol1+0x168> addu $29,$0,$30
00402d88 <uppol1+0x170> lw $30,16($29)
00402d90 <uppol1+0x178> addiu $29,$29,24
00402d98 <uppol1+0x180> jr $31
logsch():
../benchmarks/adpcm/adpcm.c:811

/* INVQAH: inverse adaptive quantizer for the higher sub-band */
/* returns dh, code table is pre-multiplied by 8 */

/*  int invqah(int ih,int deth) */
/*  { */
/*        long int rdh; */
/*        rdh = ((long)deth*qq2_code2_table[ih]) >> 15L ; */
/*        return((int)(rdh )); */
/*  } */

/* logsch - update log quantizer scale factor in higher sub-band */
/* note that nbh is passed and returned */

int logsch(int ih,int nbh)
{
00402da0 <logsch> addiu $29,$29,-16
00402da8 <logsch+0x8> sw $30,8($29)
00402db0 <logsch+0x10> addu $30,$0,$29
00402db8 <logsch+0x18> sw $4,16($30)
00402dc0 <logsch+0x20> sw $5,20($30)
../benchmarks/adpcm/adpcm.c:813
    int wd;
    wd = ((long)nbh * 127L) >> 7L;       /* leak factor 127/128 */
00402dc8 <logsch+0x28> lw $2,20($30)
00402dd0 <logsch+0x30> addu $4,$0,$2
00402dd8 <logsch+0x38> sll $3,$4,0x7
00402de0 <logsch+0x40> subu $3,$3,$2
00402de8 <logsch+0x48> sra $2,$3,0x7
00402df0 <logsch+0x50> sw $2,0($30)
../benchmarks/adpcm/adpcm.c:814
    nbh = wd + wh_code_table[ih];
00402df8 <logsch+0x58> lw $2,16($30)
00402e00 <logsch+0x60> addu $3,$0,$2
00402e08 <logsch+0x68> sll $2,$3,0x2
00402e10 <logsch+0x70> lui $3,4096
00402e18 <logsch+0x78> addiu $3,$3,1248
00402e20 <logsch+0x80> addu $2,$2,$3
00402e28 <logsch+0x88> lw $3,0($30)
00402e30 <logsch+0x90> lw $2,0($2)
00402e38 <logsch+0x98> addu $3,$3,$2
00402e40 <logsch+0xa0> sw $3,20($30)
../benchmarks/adpcm/adpcm.c:815
    if(nbh < 0) nbh = 0;
00402e48 <logsch+0xa8> lw $2,20($30)
00402e50 <logsch+0xb0> bgez $2,00402e60 <logsch+0xc0>
00402e58 <logsch+0xb8> sw $0,20($30)
../benchmarks/adpcm/adpcm.c:816
    if(nbh > 22528) nbh = 22528;
00402e60 <logsch+0xc0> lw $2,20($30)
00402e68 <logsch+0xc8> slti $3,$2,22529
00402e70 <logsch+0xd0> bne $3,$0,00402e88 <logsch+0xe8>
00402e78 <logsch+0xd8> addiu $2,$0,22528
00402e80 <logsch+0xe0> sw $2,20($30)
../benchmarks/adpcm/adpcm.c:817
    return(nbh);
00402e88 <logsch+0xe8> lw $2,20($30)
00402e90 <logsch+0xf0> j 00402e98 <logsch+0xf8>
../benchmarks/adpcm/adpcm.c:818
}
00402e98 <logsch+0xf8> addu $29,$0,$30
00402ea0 <logsch+0x100> lw $30,8($29)
00402ea8 <logsch+0x108> addiu $29,$29,16
00402eb0 <logsch+0x110> jr $31
main():
../benchmarks/adpcm/adpcm.c:823


#ifndef Seoul_Mate
int main()
{
00402eb8 <main> addiu $29,$29,-40
00402ec0 <main+0x8> sw $31,36($29)
00402ec8 <main+0x10> sw $30,32($29)
00402ed0 <main+0x18> addu $30,$0,$29
../benchmarks/adpcm/adpcm.c:828
    int i,j,f/*,answer*/;
    static int test_data[SIZE*2],compressed[SIZE],result[SIZE*2];

/* reset, initialize required memory */
     reset();
00402ed8 <main+0x20> jal 00401b18 <reset>
../benchmarks/adpcm/adpcm.c:833

/* read in amplitude and frequency for test data */
    /*  scanf("%d",&j);
  scanf("%d",&f); */
     j = 10; f = 2000;  /* krs men, anvnds inte */
00402ee0 <main+0x28> addiu $2,$0,10
00402ee8 <main+0x30> sw $2,20($30)
00402ef0 <main+0x38> addiu $2,$0,2000
00402ef8 <main+0x40> sw $2,24($30)
../benchmarks/adpcm/adpcm.c:839

/* 16 KHz sample rate */
    /* XXmain_0, MAX: 2 */
    /* Since the number of times we loop in my_sin depends on the argument we
       add the fact: xxmain_0:[]: */
    for(i = 0 ; i < SIZE ; i++) {
00402f00 <main+0x48> sw $0,16($30)
00402f08 <main+0x50> lw $2,16($30)
00402f10 <main+0x58> slti $3,$2,3
00402f18 <main+0x60> bne $3,$0,00402f28 <main+0x70>
00402f20 <main+0x68> j 00402f90 <main+0xd8>
../benchmarks/adpcm/adpcm.c:841
              //test_data[i] = (int)j*my_cos(f*PI*i); 
              test_data[i] = 1; 
00402f28 <main+0x70> lw $2,16($30)
00402f30 <main+0x78> addu $3,$0,$2
00402f38 <main+0x80> sll $2,$3,0x2
00402f40 <main+0x88> lui $3,4096
00402f48 <main+0x90> addiu $3,$3,2416
00402f50 <main+0x98> addu $2,$2,$3
00402f58 <main+0xa0> addiu $3,$0,1
00402f60 <main+0xa8> sw $3,0($2)
../benchmarks/adpcm/adpcm.c:839
00402f68 <main+0xb0> lw $3,16($30)
00402f70 <main+0xb8> addiu $2,$3,1
00402f78 <main+0xc0> addu $3,$0,$2
00402f80 <main+0xc8> sw $3,16($30)
00402f88 <main+0xd0> j 00402f08 <main+0x50>
../benchmarks/adpcm/adpcm.c:854
    }



    /* MAX: 2 */

/*******Antar att test_data[0] = 10 och test_data[1]=-6 frn ovan,          *******
        och att anropet i forloopen blir encode(test_data[0],test_data[0]);
		och encode(test_data[1],test_data[1]), eftersom att den annars gr
 *******ver array grnsen                                                  *******/


   for(i = 0 ; i < IN_END ; i += 2)
00402f90 <main+0xd8> sw $0,16($30)
00402f98 <main+0xe0> lw $2,16($30)
00402fa0 <main+0xe8> slti $3,$2,4
00402fa8 <main+0xf0> bne $3,$0,00402fb8 <main+0x100>
00402fb0 <main+0xf8> j 004030a8 <main+0x1f0>
../benchmarks/adpcm/adpcm.c:855
      compressed[i/2] = encode(test_data[i],test_data[i+1]);
00402fb8 <main+0x100> lw $2,16($30)
00402fc0 <main+0x108> addu $3,$0,$2
00402fc8 <main+0x110> sll $2,$3,0x2
00402fd0 <main+0x118> lui $3,4096
00402fd8 <main+0x120> addiu $3,$3,2416
00402fe0 <main+0x128> addu $2,$2,$3
00402fe8 <main+0x130> lw $3,16($30)
00402ff0 <main+0x138> addu $4,$0,$3
00402ff8 <main+0x140> sll $3,$4,0x2
00403000 <main+0x148> lui $4,4096
00403008 <main+0x150> addiu $4,$4,2420
00403010 <main+0x158> addu $3,$3,$4
00403018 <main+0x160> lw $4,0($2)
00403020 <main+0x168> lw $5,0($3)
00403028 <main+0x170> jal 00400710 <encode>
00403030 <main+0x178> lw $3,16($30)
00403038 <main+0x180> sra $4,$3,0x1f
00403040 <main+0x188> srl $5,$4,0x1f
00403048 <main+0x190> addu $4,$3,$5
00403050 <main+0x198> sra $3,$4,0x1
00403058 <main+0x1a0> addu $4,$0,$3
00403060 <main+0x1a8> sll $3,$4,0x2
00403068 <main+0x1b0> lui $4,4096
00403070 <main+0x1b8> addiu $4,$4,2440
00403078 <main+0x1c0> addu $3,$3,$4
00403080 <main+0x1c8> sw $2,0($3)
../benchmarks/adpcm/adpcm.c:854
00403088 <main+0x1d0> lw $2,16($30)
00403090 <main+0x1d8> addiu $3,$2,2
00403098 <main+0x1e0> sw $3,16($30)
004030a0 <main+0x1e8> j 00402f98 <main+0xe0>
../benchmarks/adpcm/adpcm.c:857
    /* MAX: 2 */
    for(i = 0 ; i < IN_END ; i += 2) {
004030a8 <main+0x1f0> sw $0,16($30)
004030b0 <main+0x1f8> lw $2,16($30)
004030b8 <main+0x200> slti $3,$2,4
004030c0 <main+0x208> bne $3,$0,004030d0 <main+0x218>
004030c8 <main+0x210> j 004031d0 <main+0x318>
../benchmarks/adpcm/adpcm.c:858
      decode(compressed[i/2]);
004030d0 <main+0x218> lw $2,16($30)
004030d8 <main+0x220> sra $3,$2,0x1f
004030e0 <main+0x228> srl $4,$3,0x1f
004030e8 <main+0x230> addu $3,$2,$4
004030f0 <main+0x238> sra $2,$3,0x1
004030f8 <main+0x240> addu $3,$0,$2
00403100 <main+0x248> sll $2,$3,0x2
00403108 <main+0x250> lui $3,4096
00403110 <main+0x258> addiu $3,$3,2440
00403118 <main+0x260> addu $2,$2,$3
00403120 <main+0x268> lw $4,0($2)
00403128 <main+0x270> jal 00401150 <decode>
../benchmarks/adpcm/adpcm.c:859
      result[i] = xout1;
00403130 <main+0x278> lw $2,16($30)
00403138 <main+0x280> addu $3,$0,$2
00403140 <main+0x288> sll $2,$3,0x2
00403148 <main+0x290> lui $3,4096
00403150 <main+0x298> addiu $3,$3,2456
00403158 <main+0x2a0> addu $2,$2,$3
00403160 <main+0x2a8> lw $3,-32540($28)
00403168 <main+0x2b0> sw $3,0($2)
../benchmarks/adpcm/adpcm.c:860
      result[i+1] = xout2;
00403170 <main+0x2b8> lw $2,16($30)
00403178 <main+0x2c0> addu $3,$0,$2
00403180 <main+0x2c8> sll $2,$3,0x2
00403188 <main+0x2d0> lui $3,4096
00403190 <main+0x2d8> addiu $3,$3,2460
00403198 <main+0x2e0> addu $2,$2,$3
004031a0 <main+0x2e8> lw $3,-32488($28)
004031a8 <main+0x2f0> sw $3,0($2)
../benchmarks/adpcm/adpcm.c:857
004031b0 <main+0x2f8> lw $2,16($30)
004031b8 <main+0x300> addiu $3,$2,2
004031c0 <main+0x308> sw $3,16($30)
004031c8 <main+0x310> j 004030b0 <main+0x1f8>
../benchmarks/adpcm/adpcm.c:874
    }
/*
for( ; j < 32767 ; j++) {
i=IN_END-1;
printf("\n%4d %4d %4d %4d %4d",j,compressed[i/2] >> 6,compressed[i/2] & 63,result[i],result[i-1]);
}
*/
/* print ih, il */
/*
    for(i = 0 ; i < IN_END/2 ; i++) printf("\n%4d %2d %2d",
        i,compressed[i] >> 6,compressed[i] & 63);
*/

    return result[i]+result[i+1];
004031d0 <main+0x318> lw $2,16($30)
004031d8 <main+0x320> addu $3,$0,$2
004031e0 <main+0x328> sll $2,$3,0x2
004031e8 <main+0x330> lui $3,4096
004031f0 <main+0x338> addiu $3,$3,2456
004031f8 <main+0x340> addu $2,$2,$3
00403200 <main+0x348> lw $3,16($30)
00403208 <main+0x350> addu $4,$0,$3
00403210 <main+0x358> sll $3,$4,0x2
00403218 <main+0x360> lui $4,4096
00403220 <main+0x368> addiu $4,$4,2460
00403228 <main+0x370> addu $3,$3,$4
00403230 <main+0x378> lw $2,0($2)
00403238 <main+0x380> lw $4,0($3)
00403240 <main+0x388> addu $3,$2,$4
00403248 <main+0x390> addu $2,$0,$3
00403250 <main+0x398> j 00403258 <main+0x3a0>
../benchmarks/adpcm/adpcm.c:875
}
00403258 <main+0x3a0> addu $29,$0,$30
00403260 <main+0x3a8> lw $31,36($29)
00403268 <main+0x3b0> lw $30,32($29)
00403270 <main+0x3b8> addiu $29,$29,40
00403278 <main+0x3c0> jr $31
